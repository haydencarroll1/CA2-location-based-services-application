{% extends "base.html" %}
{% load static %}
{% block content %}
<!-- 
  DUBLIN AMENITIES EXPLORER - POLISHED VERSION
  Features:
  - Google Maps-style bottom sheet with swipe gestures
  - Three sheet states: peek, half, full
  - Click map to minimize sheet
  - Fixed weather widget z-index
  - Improved location handling
  - Smooth animations
-->

<div class="app-container">
  <!-- Full-Screen Map -->
  <div id="map"></div>
  
  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-spinner"></div>
  </div>

  <!-- Floating Search Bar (desktop / tablet) -->
  <div class="search-container">
    <div class="search-bar">
      <div class="search-bar__icon">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/>
          <path d="m21 21-4.3-4.3"/>
        </svg>
      </div>
      <input 
        type="search" 
        class="search-bar__input" 
        placeholder="Search caf√©s, gyms, parks, ATMs..."
        autocomplete="off"
        data-role="search-input"
      >
      <button class="search-bar__btn" title="Use my location" data-role="locate-button">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"/>
          <path d="M12 2v3m0 14v3M2 12h3m14 0h3"/>
        </svg>
        Locate
      </button>
    </div>
  </div>



  <!-- Location Permission Banner (shown when needed) -->
  <div id="locationBanner" class="location-banner d-none">
    <div class="location-banner__title">üìç Enable Location</div>
    <p class="location-banner__text">Allow location access to find nearby places and get directions.</p>
    <div class="location-banner__actions">
      <button class="location-banner__btn location-banner__btn--secondary" data-action="dismiss">Not now</button>
      <button class="location-banner__btn location-banner__btn--primary" data-action="enable">Enable</button>
    </div>
  </div>

  <!-- Floating Side Panel / Bottom Sheet -->
  <aside class="side-panel" data-role="results-sheet" data-state="half">
    <!-- Drag Handle (mobile only) -->
    <button type="button" class="side-panel__handle" id="sheetHandle" aria-label="Drag to resize">
      <span class="side-panel__handle-bar"></span>
    </button>
    
    <!-- Header -->
    <div class="side-panel__header">
      <div class="side-panel__search mobile-only">
        <div class="search-bar">
          <div class="search-bar__icon">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"/>
              <path d="m21 21-4.3-4.3"/>
            </svg>
          </div>
          <input 
            type="search" 
            class="search-bar__input" 
            placeholder="Search caf√©s, gyms, parks, ATMs..."
            autocomplete="off"
            data-role="search-input"
          >
          <button class="search-bar__btn" title="Use my location" data-role="locate-button">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"/>
              <path d="M12 2v3m0 14v3M2 12h3m14 0h3"/>
            </svg>
          </button>
        </div>
      </div>
      <div style="display: flex; align-items: flex-start; justify-content: space-between; gap: var(--space-3);">
        <div>
          <h2 style="font-size: var(--text-xl); font-weight: var(--font-bold); color: var(--text-primary); margin: 0;">Explore Dublin</h2>
          <p style="font-size: var(--text-sm); color: var(--text-tertiary); margin: var(--space-1) 0 0;">Find nearby places</p>
        </div>
        <div id="liveIndicator" class="live-badge" style="display: none;">
          <span class="live-badge__dot"></span>
          Live
        </div>
      </div>
    </div>

    <!-- Scrollable Content -->
    <div class="side-panel__content">
      <!-- Controls Section -->
      <div class="side-panel__section">
        <div class="side-panel__section-title">Search Mode</div>
        <div class="mode-toggle" role="group" aria-label="Search mode">
          <button type="button" class="mode-toggle__btn active" data-mode="nearest">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
              <circle cx="12" cy="10" r="3"/>
            </svg>
            Nearby
          </button>
          <button type="button" class="mode-toggle__btn" data-mode="radius">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
              <circle cx="12" cy="10" r="3"/>
              <line x1="12" y1="22" x2="12" y2="17"/>
            </svg>
            Drop a Pin
          </button>
        </div>
        
        <!-- Radius Controls (Hidden by default) -->
        <div id="radiusControls" class="range-control d-none" style="margin-top: var(--space-3);">
          <div class="range-control__header">
            <span class="range-control__label">Search Radius</span>
            <span id="radiusValue" class="range-control__value">1.0 km</span>
          </div>
          <input 
            id="radiusKm" 
            type="range" 
            class="range-control__slider"
            min="0.2" 
            max="5" 
            step="0.1" 
            value="1.0"
          >
        </div>
      </div>

      <!-- Categories Section -->
      <div class="side-panel__section">
        <div class="side-panel__section-title">Categories</div>
        <div id="categoryChips" class="category-pills">
          <button class="category-pill active" data-category="all">
            <span class="category-pill__icon">‚ú®</span> All
          </button>
          <button class="category-pill category-pill--cafe" data-category="cafe">
            <span class="category-pill__icon">‚òï</span> Caf√©s
          </button>
          <button class="category-pill category-pill--shop" data-category="shop">
            <span class="category-pill__icon">üõí</span> Shops
          </button>
          <button class="category-pill category-pill--gym" data-category="gym">
            <span class="category-pill__icon">üí™</span> Gyms
          </button>
          <button class="category-pill category-pill--atm" data-category="atm">
            <span class="category-pill__icon">üèß</span> ATMs
          </button>
          <button class="category-pill category-pill--park" data-category="park">
            <span class="category-pill__icon">üå≥</span> Parks
          </button>
        </div>
      </div>

      <!-- Area Filter Section -->
      <div class="side-panel__section">
        <div class="select-control">
          <label class="select-control__label" for="areaSelect">Area Filter</label>
          <select id="areaSelect" class="select-control__select">
            <option value="">All areas</option>
          </select>
        </div>
      </div>

      <!-- Actions Section -->
      <div class="side-panel__section">
        <div style="display: flex; gap: var(--space-2);">
          <button id="resetView" class="btn btn-secondary" style="flex: 1;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
              <path d="M3 3v5h5"/>
            </svg>
            Reset
          </button>
          <button id="btnClearAll" class="btn btn-secondary" style="flex: 1;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6 6 18M6 6l12 12"/>
            </svg>
            Clear
          </button>
        </div>
      </div>

      <!-- Results Section -->
      <div class="side-panel__section" style="flex: 1; display: flex; flex-direction: column; min-height: 200px;">
        <div class="results-panel__header">
          <h3 class="results-panel__title">Results</h3>
          <span id="resultSummary" class="results-panel__count">Use locate or drop a pin to explore</span>
        </div>
        <div id="resultsList" class="results-panel__list" style="flex: 1; overflow-y: auto;">
          <div class="results-empty">
            <svg class="results-empty__icon" viewBox="0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"1.5\">
              <path d=\"M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z\"/>
              <circle cx=\"12\" cy=\"10\" r=\"3\"/>
            </svg>
            <div class=\"results-empty__title\">Get Started</div>
            <p class=\"results-empty__text\">Use the locate button to find places near you, or switch to \"Drop a Pin\" mode to search anywhere</p>
          </div>
        </div>
      </div>
    </div>
  </aside>

  <!-- Map Controls -->
  <div class="map-controls" id="mapControls">
    <button class="map-control-btn" id="zoomIn" title="Zoom in">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 5v14M5 12h14"/>
      </svg>
    </button>
    <button class="map-control-btn" id="zoomOut" title="Zoom out">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M5 12h14"/>
      </svg>
    </button>
    <button class="map-control-btn" id="toggleSatellite" title="Toggle satellite view">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"/>
        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        <path d="M2 12h20"/>
      </svg>
    </button>
    <button class="map-control-btn" id="toggleHeatmap" title="Toggle heatmap">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"/>
        <circle cx="12" cy="12" r="6" opacity="0.6"/>
        <circle cx="12" cy="12" r="9" opacity="0.3"/>
      </svg>
    </button>
    <button class="map-control-btn" id="themeToggle" title="Toggle light/dark mode">
      <svg class="theme-icon theme-icon--sun" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="5"/>
        <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
      </svg>
      <svg class="theme-icon theme-icon--moon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
      </svg>
    </button>
  </div>

  <!-- Map Legend -->
  <div class="map-legend" id="mapLegend">
    <div class="map-legend__item">
      <span class="map-legend__dot map-legend__dot--cafe"></span>
      Caf√©s
    </div>
    <div class="map-legend__item">
      <span class="map-legend__dot map-legend__dot--gym"></span>
      Gyms
    </div>
    <div class="map-legend__item">
      <span class="map-legend__dot map-legend__dot--park"></span>
      Parks
    </div>
    <div class="map-legend__item">
      <span class="map-legend__dot map-legend__dot--atm"></span>
      ATMs
    </div>
    <div class="map-legend__item">
      <span class="map-legend__dot map-legend__dot--shop"></span>
      Shops
    </div>
  </div>

  <!-- Status Toast -->
  <div id="statusToast" class="status-toast d-none">
    <svg class="status-toast__icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="10"/>
      <path d="M12 16v-4M12 8h.01"/>
    </svg>
    <span id="statusText" class="status-toast__text"></span>
  </div>
</div>

<script>
window.addEventListener("DOMContentLoaded", function() {
  const isAuthenticated = "{{ request.user.is_authenticated|yesno:'true,false' }}" === "true";
  window.isAuthenticated = isAuthenticated;

  function initMap() {
    if (typeof L === "undefined") {
      setTimeout(initMap, 100);
      return;
    }

    // =========================================================================
    // BOTTOM SHEET CONTROLLER - Google Maps style
    // =========================================================================
    const SheetController = {
      el: document.querySelector(".side-panel"),
      handle: document.getElementById("sheetHandle"),
      mapControls: document.getElementById("mapControls"),
      mapLegend: document.getElementById("mapLegend"),
      
      // Sheet states
      states: {
        peek: 120,
        half: window.innerHeight * 0.5,
        full: window.innerHeight * 0.85
      },
      
      currentState: "half",
      isDragging: false,
      startY: 0,
      startHeight: 0,
      
      init() {
        if (!this.el || !this.handle) return;
        
        // Only enable swipe on mobile
        const isMobile = window.matchMedia("(max-width: 767.98px)").matches;
        if (!isMobile) return;
        
        // Touch events for dragging
        this.handle.addEventListener("touchstart", this.onTouchStart.bind(this), { passive: true });
        document.addEventListener("touchmove", this.onTouchMove.bind(this), { passive: false });
        document.addEventListener("touchend", this.onTouchEnd.bind(this));
        
        // Click on handle toggles between states
        this.handle.addEventListener("click", this.cycleState.bind(this));
        
        // Update positions
        this.updateControlsPosition();
        
        // Recalculate on resize
        window.addEventListener("resize", () => {
          this.states.half = window.innerHeight * 0.5;
          this.states.full = window.innerHeight * 0.85;
          this.setState(this.currentState, false);
        });
      },
      
      onTouchStart(e) {
        this.isDragging = true;
        this.startY = e.touches[0].clientY;
        this.startHeight = this.el.getBoundingClientRect().height;
        this.el.classList.add("dragging");
      },
      
      onTouchMove(e) {
        if (!this.isDragging) return;
        
        const currentY = e.touches[0].clientY;
        const deltaY = this.startY - currentY;
        const newHeight = Math.max(
          this.states.peek, 
          Math.min(this.states.full, this.startHeight + deltaY)
        );
        
        this.el.style.setProperty("--sheet-height", `${newHeight}px`);
        this.updateControlsPosition(newHeight);
        
        // Prevent page scroll while dragging
        e.preventDefault();
      },
      
      onTouchEnd() {
        if (!this.isDragging) return;
        this.isDragging = false;
        this.el.classList.remove("dragging");
        
        const currentHeight = this.el.getBoundingClientRect().height;
        
        // Snap to nearest state
        const distances = {
          peek: Math.abs(currentHeight - this.states.peek),
          half: Math.abs(currentHeight - this.states.half),
          full: Math.abs(currentHeight - this.states.full)
        };
        
        const nearest = Object.entries(distances).sort((a, b) => a[1] - b[1])[0][0];
        this.setState(nearest, true);
      },
      
      setState(state, animate = true) {
        this.currentState = state;
        this.el.dataset.state = state;
        
        if (animate) {
          this.el.style.setProperty("--sheet-height", `${this.states[state]}px`);
        }
        
        this.updateControlsPosition(this.states[state]);
      },
      
      cycleState() {
        const order = ["peek", "half", "full"];
        const currentIndex = order.indexOf(this.currentState);
        const nextIndex = (currentIndex + 1) % order.length;
        this.setState(order[nextIndex], true);
      },
      
      // Minimize to peek when map is clicked
      minimize() {
        const isMobile = window.matchMedia("(max-width: 767.98px)").matches;
        if (isMobile && this.currentState !== "peek") {
          this.setState("peek", true);
        }
      },
      
      // Expand to half when results are loaded
      expandForResults() {
        const isMobile = window.matchMedia("(max-width: 767.98px)").matches;
        if (isMobile && this.currentState === "peek") {
          this.setState("half", true);
        }
      },
      
      updateControlsPosition(height) {
        const isMobile = window.matchMedia("(max-width: 767.98px)").matches;
        if (!isMobile) return;
        
        const sheetHeight = height || this.states[this.currentState];
        const bottom = sheetHeight + 16;
        
        if (this.mapControls) {
          this.mapControls.style.bottom = `${bottom}px`;
        }
        if (this.mapLegend) {
          this.mapLegend.style.bottom = `${bottom}px`;
        }
      }
    };

    // MAP INITIALIZATION
    const map = L.map("map", {
      scrollWheelZoom: true,
      zoomControl: false,
    }).setView([53.3498, -6.2603], 13);

    // Tile layers
    const darkTiles = L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
      maxZoom: 19,
    });

    const lightTiles = L.tileLayer("https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
      maxZoom: 19,
    });

    const satelliteTiles = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
      attribution: '&copy; Esri',
      maxZoom: 19,
    });

    let currentBaseLayer = null;
    let isSatellite = false;

    function applyBaseLayerForTheme(theme) {
      const effectiveTheme = theme || document.documentElement.dataset.theme || "dark";
      const desiredBase = effectiveTheme === "light" ? lightTiles : darkTiles;

      if (currentBaseLayer === desiredBase) return;

      if (!isSatellite && currentBaseLayer && map.hasLayer(currentBaseLayer)) {
        map.removeLayer(currentBaseLayer);
      }

      currentBaseLayer = desiredBase;

      if (!isSatellite && !map.hasLayer(currentBaseLayer)) {
        currentBaseLayer.addTo(map);
      }
    }

    // Initialize base layer using current theme
    applyBaseLayerForTheme(document.documentElement.dataset.theme);

    // Expose hook so global theme toggle can sync the map base layer
    window.updateMapTheme = function(theme) {
      applyBaseLayerForTheme(theme);
    };

    // Initialize feature modules
    if (typeof RoutingModule !== "undefined") RoutingModule.init(map);
    if (typeof WeatherModule !== "undefined") WeatherModule.init(map);

    // Initialize sheet controller
    SheetController.init();

    // Custom zoom controls
    const mapElement = document.getElementById("map");
    document.getElementById("zoomIn").addEventListener("click", () => map.zoomIn());
    document.getElementById("zoomOut").addEventListener("click", () => map.zoomOut());
    document.getElementById("toggleSatellite").addEventListener("click", () => {
      if (isSatellite) {
        map.removeLayer(satelliteTiles);
        if (currentBaseLayer && !map.hasLayer(currentBaseLayer)) {
          currentBaseLayer.addTo(map);
        }
      } else {
        if (currentBaseLayer && map.hasLayer(currentBaseLayer)) {
          map.removeLayer(currentBaseLayer);
        }
        if (!map.hasLayer(satelliteTiles)) {
          satelliteTiles.addTo(map);
        }
      }
      isSatellite = !isSatellite;
      const toggleBtn = document.getElementById("toggleSatellite");
      if (toggleBtn) {
        toggleBtn.classList.toggle("active", isSatellite);
      }
      if (mapElement) {
        mapElement.classList.toggle("map--satellite", isSatellite);
      }
    });

    // =========================================================================
    // HEATMAP LAYER
    // =========================================================================
    let heatmapLayer = null;
    let isHeatmapActive = false;

    async function loadHeatmapData() {
      try {
        const response = await fetch("/api/amenities/");
        const data = await response.json();
        
        // Extract coordinates for heatmap [lat, lng, intensity]
        const heatData = data.features.map(f => {
          const coords = f.geometry.coordinates;
          return [coords[1], coords[0], 1]; // lat, lng, intensity
        });
        
        return heatData;
      } catch (error) {
        console.error("[Heatmap] Failed to load data:", error);
        return [];
      }
    }

    document.getElementById("toggleHeatmap").addEventListener("click", async () => {
      const btn = document.getElementById("toggleHeatmap");
      
      if (isHeatmapActive) {
        // Remove heatmap
        if (heatmapLayer && map.hasLayer(heatmapLayer)) {
          map.removeLayer(heatmapLayer);
        }
        btn.classList.remove("active");
        isHeatmapActive = false;
      } else {
        // Show loading
        btn.classList.add("active");
        
        // Load data and create heatmap
        const heatData = await loadHeatmapData();
        
        if (heatData.length > 0) {
          heatmapLayer = L.heatLayer(heatData, {
            radius: 25,
            blur: 15,
            maxZoom: 17,
            max: 1.0,
            gradient: {
              0.2: '#3b82f6',
              0.4: '#22d3ee', 
              0.6: '#22c55e',
              0.8: '#facc15',
              1.0: '#ef4444'
            }
          }).addTo(map);
          isHeatmapActive = true;
        } else {
          btn.classList.remove("active");
        }
      }
    });

    // =========================================================================
    // DOM REFERENCES
    // =========================================================================
    const searchInputs = document.querySelectorAll("[data-role='search-input']");
    const radiusSection = document.getElementById("radiusControls");
    const radiusInput = document.getElementById("radiusKm");
    const radiusValueLabel = document.getElementById("radiusValue");
    const areaSelect = document.getElementById("areaSelect");
    const resultsList = document.getElementById("resultsList");
    const resultSummary = document.getElementById("resultSummary");
    const statusToast = document.getElementById("statusToast");
    const statusText = document.getElementById("statusText");
    const loadingOverlay = document.getElementById("loadingOverlay");
    const locateButtons = document.querySelectorAll("[data-role='locate-button']");
    const modeButtons = document.querySelectorAll(".mode-toggle__btn");
    const categoryChips = document.querySelectorAll(".category-pill");
    // Live OSM is always enabled
    const liveIndicator = document.getElementById("liveIndicator");
    const filtersToggle = document.getElementById("filtersToggle");
    const sidePanelEl = document.querySelector(".side-panel");
    const locationBanner = document.getElementById("locationBanner");

    // =========================================================================
    // STATE
    // =========================================================================
    const state = {
      mode: "nearest",
      selectedCategories: new Set(),
      searchTerm: "",
      userLocation: null,
      lastOrigin: { nearest: null, radius: null },
      areaId: null,
      locationAsked: false,
      lastFeatures: [], // Store raw features for re-filtering
    };

    let searchDebounce = null;
    let statusTimeout = null;

    // =========================================================================
    // ICON HANDLING
    // =========================================================================
    const amenityIconCache = new Map();
    const amenityIconSlugs = new Set(["cafe", "shop", "gym", "atm", "park", "default"]);
    
    function categoryToSlug(category) {
      if (!category) return "default";
      return amenityIconSlugs.has(category) ? category : "default";
    }

    function createAmenityIcon(category) {
      const slug = categoryToSlug(category);
      if (!amenityIconCache.has(slug)) {
        amenityIconCache.set(slug, L.icon({
          iconUrl: `/static/img/pin-${slug}.svg`,
          iconSize: [36, 44],
          iconAnchor: [18, 42],
          popupAnchor: [0, -38],
        }));
      }
      return amenityIconCache.get(slug);
    }

    const userIcon = L.divIcon({
      className: "user-marker",
      html: '<div class="user-marker__ring"></div><div class="user-marker__dot"></div>',
      iconSize: [24, 24],
      iconAnchor: [12, 12],
    });

    const radiusIcon = L.divIcon({
      className: "radius-pin-icon",
      html: "<span></span>",
      iconSize: [18, 18],
      iconAnchor: [9, 9],
    });

    // =========================================================================
    // MARKERS AND LAYERS
    // =========================================================================
    let userMarker = null;
    let userAccuracyCircle = null;
    let radiusMarker = null;
    let radiusCircle = null;
    const amenityLayerIndex = new Map();
    const favoriteIds = new Set();
    const favoriteLookup = new Map();

    // Single popup builder function
    function buildPopupContent(feature) {
      const props = feature.properties || {};
      const name = props.name || "Unnamed";
      const category = props.category || "place";
      const coords = feature.geometry?.coordinates || [];
      const lat = coords[1];
      const lng = coords[0];
      const canRoute = Number.isFinite(lat) && Number.isFinite(lng);
      const amenityId = feature.id || props.pk || props.id;
      const distanceM = props.distance_m;
      
      // Get category icon and color
      const categoryIcons = {
        cafe: { icon: '‚òï', color: '#f59e0b' },
        shop: { icon: 'üõí', color: '#0ea5e9' },
        gym: { icon: 'üí™', color: '#ef4444' },
        atm: { icon: 'üèß', color: '#3b82f6' },
        park: { icon: 'üå≥', color: '#22c55e' }
      };
      const catInfo = categoryIcons[category] || { icon: 'üìç', color: '#0ea5e9' };
      
      // Format distance
      let distanceText = '';
      if (distanceM) {
        distanceText = distanceM < 1000 
          ? `${Math.round(distanceM)}m away`
          : `${(distanceM / 1000).toFixed(1)}km away`;
      }
      
      // Build info items (only show what's available)
      const infoItems = [];
      
      if (props.addr_street) {
        infoItems.push(`<div class="popup-info-row"><span class="popup-info-icon">üìç</span><span>${props.addr_street}</span></div>`);
      }
      if (props.opening_hours) {
        infoItems.push(`<div class="popup-info-row"><span class="popup-info-icon">üïê</span><span>${props.opening_hours}</span></div>`);
      }
      if (props.phone) {
        infoItems.push(`<div class="popup-info-row"><span class="popup-info-icon">üìû</span><a href="tel:${props.phone}" class="popup-link">${props.phone}</a></div>`);
      }
      if (props.website) {
        const shortUrl = props.website.replace(/^https?:\/\/(www\.)?/, '').split('/')[0];
        infoItems.push(`<div class="popup-info-row"><span class="popup-info-icon">üåê</span><a href="${props.website}" target="_blank" class="popup-link">${shortUrl}</a></div>`);
      }
      if (props.cuisine) {
        infoItems.push(`<div class="popup-info-row"><span class="popup-info-icon">üçΩÔ∏è</span><span>${props.cuisine}</span></div>`);
      }
      if (props.operator) {
        infoItems.push(`<div class="popup-info-row"><span class="popup-info-icon">üè¢</span><span>${props.operator}</span></div>`);
      }
      if (props.description) {
        infoItems.push(`<div class="popup-info-row"><span class="popup-info-icon">üìù</span><span>${props.description}</span></div>`);
      }

      const isFav = isAuthenticated && amenityId && favoriteIds.has(String(amenityId));
      
      let html = `
        <div class="popup-card">
          <div class="popup-header">
            <div class="popup-category" style="--cat-color: ${catInfo.color}">
              <span class="popup-category__icon">${catInfo.icon}</span>
              <span class="popup-category__text">${category}</span>
            </div>
            ${distanceText ? `<span class="popup-distance">${distanceText}</span>` : ''}
          </div>
          <h3 class="popup-title">${name}</h3>
          ${infoItems.length > 0 ? `<div class="popup-info">${infoItems.slice(0, 4).join('')}</div>` : ''}
          <div class="popup-actions">
            ${canRoute ? `<button class="popup-action-btn popup-action-btn--primary" onclick="window.getDirectionsTo(${lat}, ${lng})">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 11l19-9-9 19-2-8-8-2z"/></svg>
              Directions
            </button>` : ''}
            ${isAuthenticated && amenityId ? `<button class="popup-action-btn ${isFav ? 'popup-action-btn--saved' : ''}" onclick="window.toggleFavorite(${amenityId})">
              ${isFav ? '‚òÖ' : '‚òÜ'} ${isFav ? 'Saved' : 'Save'}
            </button>` : ''}
          </div>
          ${props.source === 'OSM' ? '<div class="popup-source">Data from OpenStreetMap</div>' : ''}
        </div>
      `;
      return html;
    }

    // Layer groups
    const amenitiesLayer = L.geoJSON(null, {
      pointToLayer: (feature, latlng) => L.marker(latlng, {
        icon: createAmenityIcon(feature?.properties?.category),
        riseOnHover: true,
      }),
      onEachFeature: (feature, layer) => {
        layer.bindPopup(buildPopupContent(feature));
        const id = feature.id || feature.properties?.pk || feature.properties?.id;
        if (id) amenityLayerIndex.set(id, layer);
      }
    }).addTo(map);

    const routesLayer = L.geoJSON(null, {
      style: {
        color: "#10b981",
        weight: 4,
        opacity: 0.8,
        lineCap: "round",
        lineJoin: "round"
      },
      onEachFeature: (feature, layer) => {
        layer.bindPopup(`<strong>${feature.properties?.name || "Route"}</strong>`);
      }
    }).addTo(map);

    const areasLayer = L.geoJSON(null, {
      style: {
        color: "#0ea5e9",
        weight: 2,
        opacity: 0.6,
        fillColor: "#0ea5e9",
        fillOpacity: 0.1,
        dashArray: "8, 4"
      }
    }).addTo(map);

    // =========================================================================
    // UI FUNCTIONS
    // =========================================================================
    function setLoading(isLoading) {
      loadingOverlay.classList.toggle("active", isLoading);
    }

    function setStatus(message, type = "info") {
      statusText.textContent = message;
      statusToast.classList.remove("d-none", "status-toast--success", "status-toast--error");
      if (type === "success") statusToast.classList.add("status-toast--success");
      if (type === "danger") statusToast.classList.add("status-toast--error");
      
      if (statusTimeout) clearTimeout(statusTimeout);
      statusTimeout = setTimeout(() => statusToast.classList.add("d-none"), 4000);
    }

    function getCSRFToken() {
      const cookies = document.cookie ? document.cookie.split(";") : [];
      for (const cookie of cookies) {
        const c = cookie.trim();
        if (c.startsWith("csrftoken=")) {
          return decodeURIComponent(c.substring(10));
        }
      }
      return null;
    }

    function handleResponse(res) {
      if (!res.ok) throw new Error(`Server error: ${res.status}`);
      return res.json();
    }

    // =========================================================================
    // FAVORITES
    // =========================================================================
    function refreshFavoriteButtons() {
      document.querySelectorAll(".favorite-btn").forEach(btn => {
        const id = btn.dataset.id;
        const isFav = favoriteIds.has(id);
        btn.textContent = isFav ? "‚òÖ Saved" : "‚òÜ Save";
        btn.classList.toggle("favorite-btn--active", isFav);
      });
    }

    function loadFavorites() {
      if (!isAuthenticated) return;
      fetch("/api/favorites/", { credentials: "same-origin" })
        .then(handleResponse)
        .then(data => {
          favoriteIds.clear();
          favoriteLookup.clear();
          (data.results || data).forEach(item => {
            const amenityId = String(item.amenity_pk || item.amenity?.id);
            if (amenityId) {
              favoriteIds.add(amenityId);
              favoriteLookup.set(amenityId, item.id);
            }
          });
          refreshFavoriteButtons();
        })
        .catch(() => {});
    }

    window.toggleFavorite = function(amenityId) {
      if (!isAuthenticated) {
        setStatus("Login to save favorites", "warning");
        return;
      }
      const id = String(amenityId);
      const isFav = favoriteIds.has(id);
      const csrfToken = getCSRFToken();
      if (!csrfToken) {
        setStatus("Missing CSRF token", "danger");
        return;
      }

      if (isFav) {
        const favId = favoriteLookup.get(id);
        if (!favId) {
          favoriteIds.delete(id);
          refreshFavoriteButtons();
          return;
        }
        fetch(`/api/favorites/${favId}/`, {
          method: "DELETE",
          headers: { "X-CSRFToken": csrfToken },
          credentials: "same-origin",
        }).then(resp => {
          if (!resp.ok && resp.status !== 204) throw new Error();
          favoriteIds.delete(id);
          favoriteLookup.delete(id);
          refreshFavoriteButtons();
          setStatus("Removed from favorites", "info");
        }).catch(() => setStatus("Could not remove favorite", "danger"));
      } else {
        fetch("/api/favorites/", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-CSRFToken": csrfToken },
          credentials: "same-origin",
          body: JSON.stringify({ amenity_id: amenityId })
        }).then(handleResponse).then(created => {
          favoriteIds.add(id);
          if (created?.id) favoriteLookup.set(id, created.id);
          refreshFavoriteButtons();
          setStatus("Saved to favorites", "success");
        }).catch(() => setStatus("Could not save favorite", "danger"));
      }
    };

    window.getDirectionsTo = function(lat, lng) {
      if (typeof RoutingModule === "undefined") {
        setStatus("Routing unavailable", "warning");
        return;
      }
      if (!state.userLocation) {
        setStatus("Enable location to get directions", "warning");
        showLocationBanner();
        return;
      }
      RoutingModule.showRoute(state.userLocation, L.latLng(lat, lng), window.currentRoutingMode || "walking")
        .then(result => setStatus(`Route: ${result.durationText} (${result.distanceText})`, "success"))
        .catch(() => setStatus("Could not calculate route", "danger"));
    };

    // =========================================================================
    // LOCATION HANDLING - IMPROVED
    // =========================================================================
    function showLocationBanner() {
      if (locationBanner && !state.locationAsked) {
        locationBanner.classList.remove("d-none");
      }
    }

    function hideLocationBanner() {
      if (locationBanner) {
        locationBanner.classList.add("d-none");
      }
    }

    // Location banner buttons
    if (locationBanner) {
      locationBanner.querySelector("[data-action='dismiss']")?.addEventListener("click", () => {
        state.locationAsked = true;
        hideLocationBanner();
      });
      
      locationBanner.querySelector("[data-action='enable']")?.addEventListener("click", () => {
        state.locationAsked = true;
        hideLocationBanner();
        attemptLocateUser({ manual: true });
      });
    }

    function setUserLocation(latlng, accuracy) {
      state.userLocation = latlng;
      if (!userMarker) {
        userMarker = L.marker(latlng, { icon: userIcon }).addTo(map);
        userAccuracyCircle = L.circle(latlng, {
          radius: accuracy,
          color: "#06b6d4",
          fillColor: "#06b6d4",
          fillOpacity: 0.1,
          weight: 1
        }).addTo(map);
      } else {
        userMarker.setLatLng(latlng);
        userAccuracyCircle.setLatLng(latlng).setRadius(accuracy);
      }
      if (typeof WeatherModule !== "undefined") WeatherModule.updateForLocation(latlng);
    }

    // Fallback location (Dublin city center) when geolocation unavailable
    const DUBLIN_CENTER = L.latLng(53.3498, -6.2603);
    
    function useDefaultLocation(message) {
      setStatus(message, "warning");
      state.lastOrigin.nearest = DUBLIN_CENTER;
      map.flyTo(DUBLIN_CENTER, 14, { duration: 1 });
      fetchAmenities(DUBLIN_CENTER, "Dublin city center");
    }

    function attemptLocateUser(options = {}) {
      // Check if geolocation is supported
      if (!navigator.geolocation) {
        if (options.manual) {
          setStatus("Geolocation not supported by your browser", "danger");
        } else {
          useDefaultLocation("Geolocation not supported. Showing Dublin city center.");
        }
        return;
      }

      // Check for secure context
      const isLocalhost = ["localhost", "127.0.0.1"].includes(location.hostname);
      const isSecure = window.isSecureContext || isLocalhost;
      
      if (!isSecure) {
        // On non-secure origins, use Dublin center as fallback
        useDefaultLocation("Location unavailable (HTTPS required). Showing Dublin city center.");
        return;
      }

      // Check permission status if available (modern browsers)
      if (navigator.permissions && navigator.permissions.query) {
        navigator.permissions.query({ name: "geolocation" }).then(result => {
          if (result.state === "denied") {
            if (options.manual) {
              setStatus("Location blocked. Enable it in your browser settings.", "danger");
            }
            return;
          }
          doLocate(options);
        }).catch(() => {
          // Fallback - just try to locate
          doLocate(options);
        });
      } else {
        doLocate(options);
      }
    }

    function doLocate(options) {
      setLoading(true);
      
      navigator.geolocation.getCurrentPosition(
        pos => {
          const latlng = L.latLng(pos.coords.latitude, pos.coords.longitude);
          setUserLocation(latlng, pos.coords.accuracy);
          state.lastOrigin.nearest = latlng;
          
          // Always fly to location and search when in nearby mode or manual click
          if (options.manual || state.mode === "nearest") {
            map.flyTo(latlng, 15, { duration: 1 });
            fetchAmenities(latlng, "your location");
          }
          
          setLoading(false);
          hideLocationBanner();
        },
        err => {
          setLoading(false);
          
          if (options.manual) {
            switch (err.code) {
              case err.PERMISSION_DENIED:
                setStatus("Location permission denied. Enable it in browser settings.", "danger");
                break;
              case err.POSITION_UNAVAILABLE:
                setStatus("Location unavailable. Try again later.", "danger");
                break;
              case err.TIMEOUT:
                setStatus("Location request timed out. Try again.", "danger");
                break;
              default:
                setStatus("Could not get location", "danger");
            }
          } else if (!state.locationAsked && err.code === err.PERMISSION_DENIED) {
            // Show banner on first auto-attempt failure
            showLocationBanner();
          }
        },
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 60000 }
      );
    }

    // =========================================================================
    // UI HELPERS
    // =========================================================================
    function updateRangeLabels() {
      radiusValueLabel.textContent = `${parseFloat(radiusInput.value).toFixed(1)} km`;
    }

    function updateCategoryChipsUI() {
      categoryChips.forEach(chip => {
        const cat = chip.dataset.category;
        const isActive = cat === "all" ? state.selectedCategories.size === 0 : state.selectedCategories.has(cat);
        chip.classList.toggle("active", isActive);
      });
    }

    // Calculate distance between two points in km (Haversine formula)
    function distanceKm(lat1, lng1, lat2, lng2) {
      const R = 6371; // Earth's radius in km
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function applyFilters(features, origin = null, radiusKm = null) {
      // Get the current search origin and radius for distance filtering
      const searchOrigin = origin || state.lastOrigin[state.mode];
      const km = radiusKm || (state.mode === "radius" ? parseFloat(radiusInput.value) : null);
      
      return features.filter(f => {
        const props = f.properties || {};
        const coords = f.geometry?.coordinates;
        
        // Distance filter - ensure results are within the selected radius
        if (km && searchOrigin && coords) {
          const dist = distanceKm(searchOrigin.lat, searchOrigin.lng, coords[1], coords[0]);
          if (dist > km) return false;
        }
        
        // Category filter
        if (state.selectedCategories.size > 0 && !state.selectedCategories.has(props.category)) return false;
        
        // Search term filter
        if (state.searchTerm) {
          const searchable = [props.name, props.operator, props.cuisine, props.addr_street]
            .filter(Boolean).join(" ").toLowerCase();
          if (!searchable.includes(state.searchTerm)) return false;
        }
        return true;
      });
    }

    // Re-filter existing results without fetching new data
    function refilterResults() {
      if (!state.lastFeatures.length) return;
      
      const filtered = applyFilters(state.lastFeatures);
      syncAmenityLayer(filtered);
      renderResults(filtered);
      
      // Update summary
      const totalCount = state.lastFeatures.length;
      const filteredCount = filtered.length;
      const categoryName = state.selectedCategories.size === 1 
        ? Array.from(state.selectedCategories)[0] 
        : "places";
      resultSummary.textContent = state.selectedCategories.size > 0
        ? `${filteredCount} ${categoryName} (of ${totalCount} total)`
        : `${filteredCount} places`;
      
      setStatus(`Showing ${filteredCount} of ${totalCount} places`, "info");
    }

    function syncAmenityLayer(features) {
      amenitiesLayer.clearLayers();
      amenityLayerIndex.clear();
      if (!features.length) return;
      
      const fc = { type: "FeatureCollection", features };
      amenitiesLayer.addData(fc);
      
      amenitiesLayer.eachLayer(layer => {
        const f = layer.feature;
        const id = f?.id || f?.properties?.pk || f?.properties?.id;
        if (id) amenityLayerIndex.set(id, layer);
      });
    }

    function renderResults(features) {
      if (!features.length) {
        resultsList.innerHTML = `
          <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
            <p style="margin: 0;">No results found</p>
          </div>`;
        return;
      }
      
      resultsList.innerHTML = features.map((f, i) => {
        const props = f.properties || {};
        const id = f.id || props.pk || props.id;
        const category = props.category || "place";
        const distance = props.distance_m ? `${(props.distance_m / 1000).toFixed(2)} km` : "";
        return `
          <div class="result-card" data-id="${id}" data-category="${category}">
            <span class="result-card__index"></span>
            <div class="result-card__content">
              <div class="result-card__name">${props.name || "Unnamed"}</div>
              <div class="result-card__meta">
                <span class="result-card__category">${category}</span>
                ${distance ? `<span class="result-card__distance">${distance}</span>` : ""}
              </div>
            </div>
            ${isAuthenticated && id ? `<button class="favorite-btn ${favoriteIds.has(String(id)) ? 'favorite-btn--active' : ''}" data-id="${id}">${favoriteIds.has(String(id)) ? "‚òÖ" : "‚òÜ"}</button>` : ""}
          </div>`;
      }).join("");

      // Click handlers
      resultsList.querySelectorAll(".result-card").forEach(card => {
        card.addEventListener("click", e => {
          if (e.target.classList.contains("favorite-btn")) return;
          const layer = amenityLayerIndex.get(parseInt(card.dataset.id)) || amenityLayerIndex.get(card.dataset.id);
          if (layer) {
            map.flyTo(layer.getLatLng(), 16, { duration: 0.5 });
            layer.openPopup();
            // Minimize sheet when viewing result
            SheetController.minimize();
          }
        });
      });
      
      resultsList.querySelectorAll(".favorite-btn").forEach(btn => {
        btn.addEventListener("click", e => {
          e.stopPropagation();
          window.toggleFavorite(btn.dataset.id);
        });
      });
    }

    // =========================================================================
    // RADIUS OVERLAY
    // =========================================================================
    function updateRadiusOverlay(latlng, km) {
      const radiusM = km * 1000;
      if (!radiusMarker) {
        radiusMarker = L.marker(latlng, { icon: radiusIcon }).addTo(map);
        radiusCircle = L.circle(latlng, {
          radius: radiusM,
          className: "radius-circle",
          color: "#06b6d4",
          fillColor: "#06b6d4",
          fillOpacity: 0.08,
          weight: 2,
          dashArray: "8 4"
        }).addTo(map);
      } else {
        radiusMarker.setLatLng(latlng);
        radiusCircle.setLatLng(latlng).setRadius(radiusM);
      }
    }

    function clearRadiusOverlay() {
      if (radiusMarker) { map.removeLayer(radiusMarker); radiusMarker = null; }
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
    }

    function getSelectedCategories() {
      return state.selectedCategories.size === 0 ? [] : Array.from(state.selectedCategories);
    }

    // =========================================================================
    // FETCH AMENITIES
    // =========================================================================
    async function fetchAmenities(latlng, label, remember = true) {
      const isRadius = state.mode === "radius";
      const km = isRadius ? parseFloat(radiusInput.value) : 1;
      
      if (isRadius) {
        updateRadiusOverlay(latlng, km);
      }

      if (remember) {
        state.lastOrigin[state.mode] = latlng;
      }

      setLoading(true);

      try {
        let features = [];

        // Fetch from PostGIS database (OSM data imported on startup)
        let url;
        if (isRadius) {
          url = new URL("/api/amenities/radius", window.location.origin);
          url.searchParams.set("lat", latlng.lat);
          url.searchParams.set("lng", latlng.lng);
          url.searchParams.set("km", km);
        } else {
          url = new URL("/api/amenities/nearest", window.location.origin);
          url.searchParams.set("lat", latlng.lat);
          url.searchParams.set("lng", latlng.lng);
          url.searchParams.set("limit", "50");
        }
        if (state.areaId) url.searchParams.set("area_id", state.areaId);
        
        const fc = await fetch(url).then(handleResponse);
        features = fc.features || [];

        // Store raw features for re-filtering
        state.lastFeatures = features;
        
        const filtered = applyFilters(features, latlng, km);
        syncAmenityLayer(filtered);
        renderResults(filtered);

        const labelText = label || `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
        const areaText = state.areaId ? " in selected area" : "";
        resultSummary.textContent = `${filtered.length} places near ${labelText}${areaText}`;
        setStatus(`Found ${filtered.length} places${areaText}`, "success");

        // Expand sheet to show results
        SheetController.expandForResults();

      } catch (err) {
        console.error("fetchAmenities error:", err);
        setStatus(err.message || "Could not fetch amenities", "danger");
      } finally {
        setLoading(false);
      }
    }

    async function fetchAmenitiesInArea(areaId) {
      setLoading(true);
      try {
        const url = new URL("/api/amenities/", window.location.origin);
        url.searchParams.set("area_id", areaId);
        
        const fc = await fetch(url).then(handleResponse);
        const features = fc.features || [];
        
        // Store raw features for re-filtering
        state.lastFeatures = features;
        
        const filtered = applyFilters(features);
        
        syncAmenityLayer(filtered);
        renderResults(filtered);
        const areaName = areaSelect.options[areaSelect.selectedIndex]?.text || "selected area";
        resultSummary.textContent = `${filtered.length} places in ${areaName}`;
        setStatus(`Found ${filtered.length} places in ${areaName}`, "success");
        
        SheetController.expandForResults();
      } catch (err) {
        setStatus(err.message, "danger");
      } finally {
        setLoading(false);
      }
    }

    function replayActiveSearch() {
      // In nearby mode, always use user location
      if (state.mode === "nearest") {
        if (state.userLocation) {
          fetchAmenities(state.userLocation, "your location", false);
        }
        return;
      }
      
      // In radius mode, use last clicked location
      const origin = state.lastOrigin[state.mode];
      if (!origin) return;
      fetchAmenities(origin, null, false);
    }

    function fetchAreas(populateOnly = false) {
      return fetch("/api/areas/")
        .then(handleResponse)
        .then(fc => {
          areasLayer.clearLayers();
          if (fc.features?.length) {
            areasLayer.addData(fc);
            areaSelect.innerHTML = '<option value="">All areas</option>';
            fc.features.forEach(f => {
              const opt = document.createElement("option");
              const id = f.id || f.properties.id || f.properties.pk;
              opt.value = id;
              opt.textContent = f.properties.name || `Area ${id}`;
              areaSelect.appendChild(opt);
            });
            if (!populateOnly) {
              map.fitBounds(areasLayer.getBounds(), { padding: [50, 50] });
              setStatus(`Loaded ${fc.features.length} areas`, "success");
            }
          }
          return fc;
        })
        .catch(err => setStatus(err.message, "danger"));
    }

    function fetchRoutesIntersecting(areaId) {
      const url = new URL("/api/routes/intersecting", window.location.origin);
      url.searchParams.set("area_id", areaId);
      fetch(url)
        .then(handleResponse)
        .then(fc => {
          routesLayer.clearLayers();
          if (fc.features?.length) routesLayer.addData(fc);
        })
        .catch(() => {});
    }

    function setMode(newMode) {
      state.mode = newMode;
      radiusSection.classList.toggle("d-none", newMode !== "radius");
      map.getContainer().style.cursor = newMode === "radius" ? "crosshair" : "";
      const areaNote = state.areaId ? " (within selected area)" : "";
      
      if (newMode === "nearest") {
        setStatus("Use the locate button to find places near you", "info");
        // In nearby mode, if we have user location, search there
        if (state.userLocation) {
          fetchAmenities(state.userLocation, "your location", true);
        }
      } else {
        setStatus(`Drop a pin on the map to search within radius${areaNote}`, "info");
        clearRadiusOverlay();
      }
    }

    // =========================================================================
    // EVENT LISTENERS
    // =========================================================================
    
    // MAP CLICK - Only triggers search in "Drop a Pin" (radius) mode
    map.on("click", e => {
      // Check if click was on a marker or popup
      if (e.originalEvent.target.closest('.leaflet-marker-icon, .leaflet-popup')) {
        return;
      }
      
      // Minimize sheet first
      SheetController.minimize();
      
      // Only search on click in radius mode
      if (state.mode === "radius") {
        fetchAmenities(e.latlng);
      }
    });

    // Location buttons
    locateButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        setStatus("Finding your location‚Ä¶");
        attemptLocateUser({ manual: true });
      });
    });

    // Filters toggle
    if (filtersToggle && sidePanelEl) {
      filtersToggle.addEventListener("click", () => {
        const isOpen = sidePanelEl.classList.toggle("filters-open");
        filtersToggle.setAttribute("aria-expanded", isOpen ? "true" : "false");
        filtersToggle.querySelector(".filters-toggle__label").textContent = isOpen ? "Hide Filters" : "Filters";
      });
    }

    // Reset view
    document.getElementById("resetView").addEventListener("click", () => {
      state.areaId = null;
      state.lastOrigin = { nearest: null, radius: null };
      clearRadiusOverlay();
      amenityLayerIndex.clear();
      amenitiesLayer.clearLayers();
      routesLayer.clearLayers();
      areaSelect.value = "";
      map.setView([53.3498, -6.2603], 13);
      resultsList.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 16px; opacity: 0.5;">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
            <circle cx="12" cy="10" r="3"/>
          </svg>
          <p style="margin: 0;">${state.mode === 'radius' ? 'Drop a pin on the map to search' : 'Use the locate button to find nearby places'}</p>
        </div>`;
      resultSummary.textContent = "Use locate or drop a pin to explore";
      setStatus("View reset", "info");
    });

    // Clear all
    document.getElementById("btnClearAll").addEventListener("click", () => {
      amenitiesLayer.clearLayers();
      amenityLayerIndex.clear();
      routesLayer.clearLayers();
      clearRadiusOverlay();
      resultsList.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
          <p style="margin: 0;">Cleared ‚Äî tap map to search</p>
        </div>`;
      resultSummary.textContent = "Tap the map to explore";
      setStatus("Cleared all results", "info");
    });

    // Mode toggle
    modeButtons.forEach(btn => {
      btn.addEventListener("click", e => {
        modeButtons.forEach(b => b.classList.remove("active"));
        e.currentTarget.classList.add("active");
        setMode(e.currentTarget.dataset.mode);
      });
    });

    // Category chips - clicking one category shows only that category
    // clicking the same one again clears the filter (shows all)
    categoryChips.forEach(chip => {
      chip.addEventListener("click", () => {
        const cat = chip.dataset.category;
        if (cat === "all") {
          // Clear all filters - show everything
          state.selectedCategories.clear();
        } else {
          // If this category is the only one selected, clear it (toggle off)
          // Otherwise, select only this category
          if (state.selectedCategories.size === 1 && state.selectedCategories.has(cat)) {
            state.selectedCategories.clear();
          } else {
            state.selectedCategories.clear();
            state.selectedCategories.add(cat);
          }
        }
        updateCategoryChipsUI();
        // Re-filter existing results instead of re-fetching
        refilterResults();
      });
    });

    // Search amenities from API
    async function searchAmenities(query) {
      if (!query || query.length < 2) {
        setStatus("Type at least 2 characters to search", "info");
        return;
      }
      
      setLoading(true);
      try {
        const url = new URL("/api/amenities/search", window.location.origin);
        url.searchParams.set("q", query);
        if (state.selectedCategories.size === 1) {
          url.searchParams.set("category", Array.from(state.selectedCategories)[0]);
        }
        
        const fc = await fetch(url).then(handleResponse);
        const features = fc.features || [];
        
        // Store for re-filtering
        state.lastFeatures = features;
        
        syncAmenityLayer(features);
        renderResults(features);
        
        resultSummary.textContent = `${features.length} results for "${query}"`;
        setStatus(`Found ${features.length} places matching "${query}"`, "success");
        
        // Fit map to results if we have any
        if (features.length > 0) {
          const bounds = amenitiesLayer.getBounds();
          if (bounds.isValid()) {
            map.fitBounds(bounds, { padding: [50, 50], maxZoom: 15 });
          }
        }
        
        SheetController.expandForResults();
      } catch (err) {
        console.error("Search error:", err);
        setStatus(err.message || "Search failed", "danger");
      } finally {
        setLoading(false);
      }
    }

    // Search input
    searchInputs.forEach(input => {
      input.addEventListener("input", () => {
        if (searchDebounce) clearTimeout(searchDebounce);
        const value = input.value.trim();
        searchDebounce = setTimeout(() => {
          state.searchTerm = value.toLowerCase();
          searchInputs.forEach(other => {
            if (other !== input) other.value = input.value;
          });
          
          // Always search API when typing 2+ characters
          if (value.length >= 2) {
            searchAmenities(value);
          } else if (value.length === 0 && state.lastFeatures.length > 0) {
            // Clear search - show all loaded results
            refilterResults();
          }
        }, 400);
      });
      
      // Also search on Enter key
      input.addEventListener("keydown", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          const value = input.value.trim();
          if (value.length >= 2) {
            searchAmenities(value);
          }
        }
      });
    });

    // Using database - no live indicator needed
    liveIndicator.style.display = "none";

    // Area select
    areaSelect.addEventListener("change", e => {
      const areaId = e.target.value;
      state.areaId = areaId || null;
      
      if (!areaId) {
        routesLayer.clearLayers();
        setStatus("Area filter cleared", "info");
        replayActiveSearch();
        return;
      }
      
      const layer = areasLayer.getLayers().find(l => {
        const f = l.feature || {};
        const id = f.id || f.properties?.id || f.properties?.pk;
        return String(id) === areaId;
      });
      
      if (layer) {
        map.fitBounds(layer.getBounds(), { padding: [50, 50] });
        fetchRoutesIntersecting(areaId);
        fetchAmenitiesInArea(areaId);
      }
    });

    // Radius slider
    radiusInput.addEventListener("input", () => {
      updateRangeLabels();
      if (state.mode === "radius") replayActiveSearch();
    });

    // =========================================================================
    // INITIALIZATION
    // =========================================================================
    if (isAuthenticated) loadFavorites();
    updateCategoryChipsUI();
    fetchAreas(true);
    updateRangeLabels();
    setMode(state.mode);
    
    // Attempt to get location on load (will show banner if denied)
    attemptLocateUser();
  }

  initMap();
});
</script>
{% endblock %}
