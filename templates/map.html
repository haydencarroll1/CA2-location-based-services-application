{% extends "base.html" %}
{% block content %}
<!-- 
  DUBLIN AMENITIES EXPLORER - 2025 REDESIGN
  Full-screen immersive map with floating glass panels
  Inspired by Google Maps & Apple Maps
-->

<div class="app-container">
  <!-- Full-Screen Map -->
  <div id="map"></div>
  
  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-spinner"></div>
  </div>

  <!-- Floating Search Bar (Google Maps Style) -->
  <div class="search-bar-container">
    <div class="search-bar">
      <svg class="search-bar__icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="11" cy="11" r="8"/>
        <path d="m21 21-4.3-4.3"/>
      </svg>
      <input 
        id="searchInput" 
        type="search" 
        class="search-bar__input" 
        placeholder="Search caf√©s, gyms, parks, ATMs..."
        autocomplete="off"
      >
      <button id="locateMe" class="search-bar__btn" title="Use my location">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"/>
          <path d="M12 2v4m0 12v4M2 12h4m12 0h4"/>
        </svg>
      </button>
    </div>
  </div>

  <!-- Brand Badge (Top Right) -->
  <div class="brand-badge">
    <div class="brand-badge__logo">DAE</div>
    <div>
      <div class="brand-badge__text">Dublin Explorer</div>
      <div class="brand-badge__tech">Leaflet ¬∑ PostGIS</div>
    </div>
  </div>

  <!-- Floating Side Panel -->
  <aside class="side-panel">
    <!-- Control Panel -->
    <div class="glass-panel control-panel">
      <div class="panel-header">
        <div>
          <h2 class="panel-title">Explore Dublin</h2>
          <p class="panel-subtitle">Find nearby places</p>
        </div>
        <div class="live-badge">
          <span class="live-badge__dot"></span>
          Live
        </div>
      </div>

      <!-- Mode Toggle -->
      <div class="mode-toggle" role="group" aria-label="Search mode">
        <button type="button" class="mode-toggle__btn active" data-mode="nearest">
          <span>üìç</span> Nearby
        </button>
        <button type="button" class="mode-toggle__btn" data-mode="radius">
          <span>‚≠ï</span> Radius
        </button>
      </div>

      <!-- Categories -->
      <div class="category-section">
        <div class="section-label">Categories</div>
        <div id="categoryChips" class="category-pills">
          <button class="category-pill active" data-category="all">
            <span class="category-pill__icon">‚ú®</span> All
          </button>
          <button class="category-pill" data-category="cafe">
            <span class="category-pill__icon">‚òï</span> Caf√©s
          </button>
          <button class="category-pill" data-category="shop">
            <span class="category-pill__icon">üõí</span> Shops
          </button>
          <button class="category-pill" data-category="gym">
            <span class="category-pill__icon">üí™</span> Gyms
          </button>
          <button class="category-pill" data-category="atm">
            <span class="category-pill__icon">üèß</span> ATMs
          </button>
          <button class="category-pill" data-category="park">
            <span class="category-pill__icon">üå≥</span> Parks
          </button>
        </div>
      </div>

      <!-- Live OSM Toggle -->
      <div class="category-section">
        <div class="section-label">Live OSM data</div>
        <label class="switch-row">
          <div>
            <div class="fw-semibold">Overpass API</div>
            <div class="muted small">Fetch fresh amenities straight from OpenStreetMap.</div>
          </div>
          <div class="form-check form-switch mb-0">
            <input class="form-check-input" type="checkbox" role="switch" id="liveToggle">
          </div>
        </label>
      </div>

      <!-- Radius Controls (Hidden by default) -->
      <div id="radiusControls" class="radius-control d-none">
        <div class="radius-control__header">
          <span class="section-label">Search Radius</span>
          <span id="radiusValue" class="radius-control__value">1.0 km</span>
        </div>
        <input 
          id="radiusKm" 
          type="range" 
          class="radius-slider"
          min="0.2" 
          max="5" 
          step="0.1" 
          value="1.0"
        >
      </div>

      <!-- Area Select -->
      <div class="area-select-wrapper">
        <div class="section-label">Area Filter</div>
        <select id="areaSelect" class="area-select">
          <option value="">Select an area to explore</option>
        </select>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons">
        <div class="btn-row">
          <button id="resetView" class="btn btn-secondary">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
              <path d="M3 3v5h5"/>
            </svg>
            Reset
          </button>
          <button id="btnClearRoutes" class="btn btn-secondary">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6 6 18M6 6l12 12"/>
            </svg>
            Clear
          </button>
        </div>
      </div>
    </div>

    <!-- Results Panel -->
    <div class="glass-panel results-panel">
      <div class="results-panel__header">
        <h3 class="results-panel__title">Results</h3>
        <div id="resultSummary" class="results-panel__count">Click the map to explore</div>
      </div>
      <div id="resultsList" class="results-panel__list">
        <!-- Results will be injected here -->
        <div class="empty-state" style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 16px; opacity: 0.5;">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
            <circle cx="12" cy="10" r="3"/>
          </svg>
          <p style="margin: 0;">Click anywhere on the map<br>to discover nearby places</p>
        </div>
      </div>
    </div>
  </aside>

  <!-- Map Controls (Bottom Right) -->
  <div class="map-controls">
    <button class="map-control-btn" id="zoomIn" title="Zoom in">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 5v14M5 12h14"/>
      </svg>
    </button>
    <button class="map-control-btn" id="zoomOut" title="Zoom out">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M5 12h14"/>
      </svg>
    </button>
    <button class="map-control-btn" id="toggleSatellite" title="Toggle satellite view">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"/>
        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        <path d="M2 12h20"/>
      </svg>
    </button>
  </div>

  <!-- Map Legend -->
  <div class="map-legend">
    <div class="legend-item">
      <span class="legend-dot legend-dot--amenity"></span>
      Amenities
    </div>
    <div class="legend-item">
      <span class="legend-dot legend-dot--route"></span>
      Routes
    </div>
    <div class="legend-item">
      <span class="legend-dot legend-dot--area"></span>
      Areas
    </div>
    <div class="legend-item legend-item--clickable" onclick="window.HeatmapModule && HeatmapModule.toggle()">
      <span class="legend-dot legend-dot--heat"></span>
      Heatmap
    </div>
  </div>

  <!-- Status Toast -->
  <div id="statusToast" class="status-toast d-none">
    <svg class="status-toast__icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="10"/>
      <path d="M12 16v-4M12 8h.01"/>
    </svg>
    <span id="statusText" class="status-toast__text"></span>
  </div>
</div>

<script>
window.addEventListener("DOMContentLoaded", function() {
  const isAuthenticated = {{ request.user.is_authenticated|yesno:"true,false" }};
  window.isAuthenticated = isAuthenticated;
  function initMap() {
    if (typeof L === "undefined") {
      setTimeout(initMap, 100);
      return;
    }

    // Initialize map with dark theme
    const map = L.map("map", {
      scrollWheelZoom: true,
      zoomControl: false, // We use custom controls
    }).setView([53.3498, -6.2603], 13);

    // Dark tile layer (CartoDB Dark Matter)
    const darkTiles = L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
      maxZoom: 19,
    }).addTo(map);

    // Satellite layer (for toggle)
    const satelliteTiles = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
      attribution: '&copy; Esri',
      maxZoom: 19,
    });

    let isSatellite = false;

    // Feature modules (routing, heatmap, weather)
    if (typeof RoutingModule !== "undefined") {
      RoutingModule.init(map);
      if (typeof addRoutingUI === "function") {
        addRoutingUI(map);
      }
    }
    if (typeof HeatmapModule !== "undefined") {
      HeatmapModule.init(map);
    }
    if (typeof WeatherModule !== "undefined") {
      WeatherModule.init(map);
    }

    // Custom zoom controls
    document.getElementById("zoomIn").addEventListener("click", () => map.zoomIn());
    document.getElementById("zoomOut").addEventListener("click", () => map.zoomOut());
    document.getElementById("toggleSatellite").addEventListener("click", () => {
      if (isSatellite) {
        map.removeLayer(satelliteTiles);
        map.addLayer(darkTiles);
      } else {
        map.removeLayer(darkTiles);
        map.addLayer(satelliteTiles);
      }
      isSatellite = !isSatellite;
      document.getElementById("toggleSatellite").classList.toggle("active", isSatellite);
    });

    // DOM references
    const searchInput = document.getElementById("searchInput");
    const radiusSection = document.getElementById("radiusControls");
    const radiusInput = document.getElementById("radiusKm");
    const radiusValueLabel = document.getElementById("radiusValue");
    const areaSelect = document.getElementById("areaSelect");
    const resultsList = document.getElementById("resultsList");
    const resultSummary = document.getElementById("resultSummary");
    const statusToast = document.getElementById("statusToast");
    const statusText = document.getElementById("statusText");
    const loadingOverlay = document.getElementById("loadingOverlay");
    const locateButton = document.getElementById("locateMe");
    const modeButtons = document.querySelectorAll(".mode-toggle__btn");
    const categoryChips = document.querySelectorAll(".category-pill");
    const liveToggle = document.getElementById("liveToggle");

    // State
    const state = {
      mode: "nearest",
      selectedCategories: new Set(),
      searchTerm: "",
      userLocation: null,
      lastOrigin: { nearest: null, radius: null },
      areaId: null,
      useLiveOSM: false,
    };
    if (liveToggle) state.useLiveOSM = liveToggle.checked;

    let searchDebounce = null;
    let statusTimeout = null;

    // Icon cache
    const amenityIconCache = new Map();
    const amenityIconSlugs = new Set(["cafe", "shop", "gym", "atm", "park", "default"]);
    
    function categoryToSlug(category) {
      if (!category) return "default";
      return amenityIconSlugs.has(category) ? category : "default";
    }

    function createAmenityIcon(category) {
      const slug = categoryToSlug(category);
      if (!amenityIconCache.has(slug)) {
        const iconUrl = `/static/img/pin-${slug}.svg`;
        amenityIconCache.set(slug, L.icon({
          iconUrl,
          iconSize: [36, 44],
          iconAnchor: [18, 42],
          popupAnchor: [0, -38],
        }));
      }
      return amenityIconCache.get(slug);
    }

    // User location icon with pulsing effect
    const userIcon = L.divIcon({
      className: "user-marker",
      html: `
        <div class="user-marker__ring"></div>
        <div class="user-marker__dot"></div>
      `,
      iconSize: [24, 24],
      iconAnchor: [12, 12],
    });

    const radiusIcon = L.divIcon({
      className: "radius-pin-icon",
      html: "<span></span>",
      iconSize: [18, 18],
      iconAnchor: [9, 9],
    });

    // Layer groups
    let userMarker = null;
    let userAccuracyCircle = null;
    let radiusMarker = null;
    let radiusCircle = null;
    const amenityLayerIndex = new Map();

    const amenitiesLayer = L.geoJSON(null, {
      pointToLayer: (feature, latlng) => {
        const category = feature?.properties?.category;
        return L.marker(latlng, {
          icon: createAmenityIcon(category),
          riseOnHover: true,
        });
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties || {};
        const name = props.name || "Unnamed";
        const category = props.category || "place";
        const address = props.addr_street || "";
        const coords = feature.geometry?.coordinates || [];
        const lat = coords[1];
        const lng = coords[0];
        const canRoute = Number.isFinite(lat) && Number.isFinite(lng);
        const amenityId = feature.id || props.pk || props.id;
        
        layer.bindPopup(`
          <div style="min-width: 180px;">
            <strong style="font-size: 14px; display: block; margin-bottom: 4px;">${name}</strong>
            <span style="display: inline-block; padding: 2px 8px; background: rgba(139, 92, 246, 0.2); border-radius: 4px; font-size: 11px; text-transform: uppercase; margin-bottom: 6px;">${category}</span>
            ${address ? `<p style="margin: 0; font-size: 12px; color: #94a3b8;">${address}</p>` : ''}
            ${canRoute ? `
              <button class="popup-route-btn" onclick="window.getDirectionsTo(${lat}, ${lng})">
                üß≠ Get Directions
              </button>
            ` : ''}
            ${isAuthenticated && amenityId ? `
              <button class="popup-route-btn" onclick="window.toggleFavorite(${amenityId})">
                ${favoriteIds.has(String(amenityId)) ? "‚òÖ Saved" : "‚òÜ Save"}
              </button>
            ` : ''}
          </div>
        `);
        const id = feature.id || feature.properties?.pk || feature.properties?.id;
        if (id) amenityLayerIndex.set(id, layer);
      }
    }).addTo(map);

    const routesLayer = L.geoJSON(null, {
      style: {
        color: "#10b981",
        weight: 4,
        opacity: 0.8,
        lineCap: "round",
        lineJoin: "round"
      },
      onEachFeature: (feature, layer) => {
        const props = feature.properties || {};
        layer.bindPopup(`<strong>${props.name || "Route"}</strong>`);
      }
    }).addTo(map);

    const areasLayer = L.geoJSON(null, {
      style: {
        color: "#8b5cf6",
        weight: 2,
        opacity: 0.6,
        fillColor: "#8b5cf6",
        fillOpacity: 0.1,
        dashArray: "8, 4"
      }
    }).addTo(map);

    // UI Functions
    function setLoading(isLoading) {
      loadingOverlay.classList.toggle("active", isLoading);
    }

    function setStatus(message, type = "info") {
      statusText.textContent = message;
      statusToast.classList.remove("d-none", "status-toast--success", "status-toast--error");
      if (type === "success") statusToast.classList.add("status-toast--success");
      if (type === "danger") statusToast.classList.add("status-toast--error");
      
      if (statusTimeout) clearTimeout(statusTimeout);
      statusTimeout = setTimeout(() => {
        statusToast.classList.add("d-none");
      }, 4000);
    }

    function getCSRFToken() {
      const name = "csrftoken";
      const cookies = document.cookie ? document.cookie.split(";") : [];
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.startsWith(name + "=")) {
          return decodeURIComponent(cookie.substring(name.length + 1));
        }
      }
      return null;
    }

    const favoriteIds = new Set();
    const favoriteLookup = new Map(); // amenityId -> favoriteId

    function refreshFavoriteButtons() {
      document.querySelectorAll(".favorite-btn").forEach(btn => {
        const id = btn.dataset.id;
        const isFav = favoriteIds.has(id);
        btn.textContent = isFav ? "‚òÖ Saved" : "‚òÜ Save";
        btn.classList.toggle("favorite-btn--active", isFav);
      });
    }

    function loadFavorites() {
      if (!isAuthenticated) return;
      fetch("/api/favorites/", { credentials: "same-origin" })
        .then(handleResponse)
        .then(data => {
          favoriteIds.clear();
          favoriteLookup.clear();
          (data.results || data).forEach(item => {
            const amenityId = String(item.amenity_pk || item.amenity?.id);
            if (amenityId) {
              favoriteIds.add(amenityId);
              favoriteLookup.set(amenityId, item.id);
            }
          });
          refreshFavoriteButtons();
        })
        .catch(() => setStatus("Could not load favorites", "warning"));
    }

    window.toggleFavorite = function(amenityId) {
      if (!isAuthenticated) {
        setStatus("Login to save favorites", "warning");
        return;
      }
      const id = String(amenityId);
      const isFav = favoriteIds.has(id);
      const csrfToken = getCSRFToken();
      if (!csrfToken) {
        setStatus("Missing CSRF token", "danger");
        return;
      }
      if (isFav) {
        const favId = favoriteLookup.get(id);
        if (!favId) {
          favoriteIds.delete(id);
          refreshFavoriteButtons();
          return;
        }
        fetch(`/api/favorites/${favId}/`, {
          method: "DELETE",
          headers: { "X-CSRFToken": csrfToken },
          credentials: "same-origin",
        })
          .then(resp => {
            if (!resp.ok && resp.status !== 204) throw new Error("Delete failed");
            favoriteIds.delete(id);
            favoriteLookup.delete(id);
            refreshFavoriteButtons();
            setStatus("Removed from favorites", "info");
          })
          .catch(() => setStatus("Could not remove favorite", "danger"));
        return;
      }
      fetch("/api/favorites/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-CSRFToken": csrfToken,
        },
        credentials: "same-origin",
        body: JSON.stringify({ amenity_id: amenityId })
      })
        .then(handleResponse)
        .then((created) => {
          favoriteIds.add(id);
          if (created && created.id) {
            favoriteLookup.set(id, created.id);
          }
          refreshFavoriteButtons();
          setStatus("Saved to favorites", "success");
        })
        .catch(() => setStatus("Could not save favorite", "danger"));
    };

    // Directions entry point for popup buttons
    window.getDirectionsTo = function(lat, lng) {
      if (typeof RoutingModule === "undefined") {
        setStatus("Routing is unavailable right now", "warning");
        return;
      }
      if (!state.userLocation) {
        setStatus("Enable location to get directions", "warning");
        return;
      }
      const destination = L.latLng(lat, lng);
      const mode = window.currentRoutingMode || "walking";
      RoutingModule.showRoute(state.userLocation, destination, mode)
        .then(result => {
          setStatus(`Route: ${result.durationText} (${result.distanceText})`, "success");
        })
        .catch(() => {
          setStatus("Could not calculate route", "danger");
        });
    };

    function updateRangeLabels() {
      const km = parseFloat(radiusInput.value).toFixed(1);
      radiusValueLabel.textContent = `${km} km`;
    }

    function updateCategoryChipsUI() {
      categoryChips.forEach(chip => {
        const cat = chip.dataset.category;
        const isActive = cat === "all" 
          ? state.selectedCategories.size === 0 
          : state.selectedCategories.has(cat);
        chip.classList.toggle("active", isActive);
      });
    }

    function handleResponse(res) {
      if (!res.ok) throw new Error(`Server error: ${res.status}`);
      return res.json();
    }

    function applyFilters(features) {
      return features.filter(f => {
        const props = f.properties || {};
        // Category filter
        if (state.selectedCategories.size > 0 && !state.selectedCategories.has(props.category)) {
          return false;
        }
        // Text search
        if (state.searchTerm) {
          const searchable = [props.name, props.operator, props.cuisine, props.addr_street]
            .filter(Boolean)
            .join(" ")
            .toLowerCase();
          if (!searchable.includes(state.searchTerm)) return false;
        }
        return true;
      });
    }

    function syncAmenityLayer(features) {
      amenitiesLayer.clearLayers();
      amenityLayerIndex.clear();
      features.forEach(f => {
        const layer = L.geoJSON(f, {
          pointToLayer: (feature, latlng) => L.marker(latlng, { icon: createAmenityIcon(feature.properties?.category), riseOnHover: true }),
          onEachFeature: (feature, layer) => {
            const props = feature.properties || {};
            const coords = feature.geometry?.coordinates || [];
            const lat = coords[1];
            const lng = coords[0];
            const canRoute = Number.isFinite(lat) && Number.isFinite(lng);
            const amenityId = feature.id || props.pk || props.id;
            layer.bindPopup(`
              <div style="min-width: 180px;">
                <strong style="font-size: 14px; display: block; margin-bottom: 4px;">${props.name || "Unnamed"}</strong>
                <span style="display: inline-block; padding: 2px 8px; background: rgba(139, 92, 246, 0.2); border-radius: 4px; font-size: 11px; text-transform: uppercase; margin-bottom: 6px;">${props.category || "place"}</span>
                ${canRoute ? `
                  <button class="popup-route-btn" onclick="window.getDirectionsTo(${lat}, ${lng})">
                    üß≠ Get Directions
                  </button>
                ` : ''}
                ${isAuthenticated && amenityId ? `
                  <button class="popup-route-btn" onclick="window.toggleFavorite(${amenityId})">
                    ${favoriteIds.has(String(amenityId)) ? "‚òÖ Saved" : "‚òÜ Save"}
                  </button>
                ` : ''}
              </div>
            `);
          }
        }).addTo(amenitiesLayer);
        const id = f.id || f.properties?.pk || f.properties?.id;
        if (id) amenityLayerIndex.set(id, layer);
      });
    }

    function renderResults(features) {
      if (!features.length) {
        resultsList.innerHTML = `
          <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
            <p style="margin: 0;">No results found</p>
          </div>
        `;
        return;
      }
      
      resultsList.innerHTML = features.map((f, i) => {
        const props = f.properties || {};
        const id = f.id || props.pk || props.id;
        const distance = props.distance_m ? `${(props.distance_m / 1000).toFixed(2)} km` : "";
        return `
          <div class="result-card" data-id="${id}">
            <span class="result-card__index">${i + 1}</span>
            <div class="result-card__content">
              <div class="result-card__title">${props.name || "Unnamed"}</div>
              <div class="result-card__meta">
                <span class="result-card__badge">${props.category || "place"}</span>
                ${distance ? `<span class="result-card__distance">${distance}</span>` : ""}
              </div>
            </div>
            ${isAuthenticated && id ? `<button class="favorite-btn" data-id="${id}" type="button">${favoriteIds.has(String(id)) ? "‚òÖ Saved" : "‚òÜ Save"}</button>` : ""}
          </div>
        `;
      }).join("");

      // Add click handlers
      resultsList.querySelectorAll(".result-card").forEach(card => {
        card.addEventListener("click", (e) => {
          if (e.target.classList.contains("favorite-btn")) return;
          const id = card.dataset.id;
          const layer = amenityLayerIndex.get(parseInt(id)) || amenityLayerIndex.get(id);
          if (layer) {
            const lyr = layer.getLayers()[0];
            if (lyr) {
              map.flyTo(lyr.getLatLng(), 16, { duration: 0.5 });
              lyr.openPopup();
            }
          }
        });
      });
      resultsList.querySelectorAll(".favorite-btn").forEach(btn => {
        btn.addEventListener("click", (e) => {
          e.stopPropagation();
          const id = btn.dataset.id;
          window.toggleFavorite(id);
        });
      });
    }

    // Location tracking
    function setUserLocation(latlng, accuracy) {
      state.userLocation = latlng;
      if (!userMarker) {
        userMarker = L.marker(latlng, { icon: userIcon }).addTo(map);
        userAccuracyCircle = L.circle(latlng, {
          radius: accuracy,
          color: "#06b6d4",
          fillColor: "#06b6d4",
          fillOpacity: 0.1,
          weight: 1
        }).addTo(map);
      } else {
        userMarker.setLatLng(latlng);
        userAccuracyCircle.setLatLng(latlng).setRadius(accuracy);
      }
      if (typeof WeatherModule !== "undefined") {
        WeatherModule.updateForLocation(latlng);
      }
    }

    function attemptLocateUser(options = {}) {
      if (!navigator.geolocation) {
        setStatus("Geolocation not supported", "danger");
        return;
      }
      setLoading(true);
      navigator.geolocation.getCurrentPosition(
        pos => {
          const latlng = L.latLng(pos.coords.latitude, pos.coords.longitude);
          setUserLocation(latlng, pos.coords.accuracy);
          state.lastOrigin.nearest = latlng;
          if (options.manual) {
            map.flyTo(latlng, 15, { duration: 1 });
            fetchAmenitiesNearest(latlng, "your location", false);
          }
          setLoading(false);
        },
        err => {
          setStatus("Could not get location", "danger");
          setLoading(false);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    // Radius overlay
    function updateRadiusOverlay(latlng, km) {
      const radiusM = km * 1000;
      if (!radiusMarker) {
        radiusMarker = L.marker(latlng, { icon: radiusIcon }).addTo(map);
        radiusCircle = L.circle(latlng, {
          radius: radiusM,
          className: "radius-circle",
          color: "#06b6d4",
          fillColor: "#06b6d4",
          fillOpacity: 0.08,
          weight: 2,
          dashArray: "8 4"
        }).addTo(map);
      } else {
        radiusMarker.setLatLng(latlng);
        radiusCircle.setLatLng(latlng).setRadius(radiusM);
      }
    }

    function clearRadiusOverlay() {
      if (radiusMarker) { map.removeLayer(radiusMarker); radiusMarker = null; }
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
    }

    function rememberOrigin(mode, latlng, save = true) {
      if (save) state.lastOrigin[mode] = latlng;
    }

    function getSelectedCategories() {
      if (state.selectedCategories.size === 0) return [];
      return Array.from(state.selectedCategories);
    }

    function replayActiveSearch() {
      const origin = state.lastOrigin[state.mode];
      if (!origin) return;
      if (state.mode === "radius") {
        fetchAmenitiesRadius(origin, null, false);
      } else {
        fetchAmenitiesNearest(origin, null, false);
      }
    }

    // API calls
    async function fetchAmenitiesNearest(latlng, subjectLabel, remember = true, forceLocal = false) {
      clearRadiusOverlay();
      setLoading(true);
      const label = subjectLabel || `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
      setStatus(`Finding places near ${label}‚Ä¶`);

      const preferLive = !forceLocal && state.useLiveOSM && typeof LiveOSM !== "undefined";
      const bounds = map.getBounds();

      try {
        let features = [];
        if (preferLive) {
          features = await LiveOSM.fetchAmenities(latlng.lat, latlng.lng, 1, getSelectedCategories(), bounds);
        } else {
          const url = new URL("/api/amenities/nearest", window.location.origin);
          url.searchParams.set("lat", latlng.lat);
          url.searchParams.set("lng", latlng.lng);
          url.searchParams.set("limit", 20);
          const fc = await fetch(url).then(handleResponse);
          features = fc.features || [];
        }

        features = applyFilters(features);
        syncAmenityLayer(features);
        if (typeof HeatmapModule !== "undefined") {
          HeatmapModule.setData(features);
        }
        if (features.length) map.flyTo(latlng, Math.max(map.getZoom(), 15), { duration: 0.5 });
        renderResults(features);
        setStatus(`Found ${features.length} places nearby`, "success");
        resultSummary.textContent = `${features.length} places near ${label}`;
      } catch (err) {
        if (preferLive) {
          setStatus("Live OSM unavailable, using local data", "warning");
          return fetchAmenitiesNearest(latlng, subjectLabel, remember, true);
        }
        setStatus(err.message || "Unable to fetch data", "danger");
      } finally {
        setLoading(false);
      }

      rememberOrigin("nearest", latlng, remember);
    }

    async function fetchAmenitiesRadius(latlng, subjectLabel, remember = true, forceLocal = false) {
      const km = parseFloat(radiusInput.value);
      updateRadiusOverlay(latlng, km);
      setLoading(true);
      const label = subjectLabel || `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
      setStatus(`Searching within ${km} km of ${label}‚Ä¶`);

      const preferLive = !forceLocal && state.useLiveOSM && typeof LiveOSM !== "undefined";
      const bounds = map.getBounds();

      try {
        let features = [];
        let routesFC = { features: [] };
        let amenitiesFC = { features: [] };

        if (preferLive) {
          features = await LiveOSM.fetchAmenities(latlng.lat, latlng.lng, km, getSelectedCategories(), bounds);
        } else {
          const amenitiesUrl = new URL("/api/amenities/radius", window.location.origin);
          amenitiesUrl.searchParams.set("lat", latlng.lat);
          amenitiesUrl.searchParams.set("lng", latlng.lng);
          amenitiesUrl.searchParams.set("km", km);

          const routesUrl = new URL("/api/routes/radius", window.location.origin);
          routesUrl.searchParams.set("lat", latlng.lat);
          routesUrl.searchParams.set("lng", latlng.lng);
          routesUrl.searchParams.set("km", km);

          [amenitiesFC, routesFC] = await Promise.all([
            fetch(amenitiesUrl).then(handleResponse),
            fetch(routesUrl).then(handleResponse)
          ]);
          features = amenitiesFC.features || [];
        }

        features = applyFilters(features);
        syncAmenityLayer(features);
        if (typeof HeatmapModule !== "undefined") {
          HeatmapModule.setData(features);
        }
        routesLayer.clearLayers();
        if (routesFC.features?.length) routesLayer.addData(routesFC);
        if (features.length) map.flyTo(latlng, Math.max(map.getZoom(), 14), { duration: 0.5 });
        renderResults(features);
        setStatus(`Found ${features.length} amenities${routesFC.features?.length ? ` and ${routesFC.features.length} routes` : ""}`, "success");
        resultSummary.textContent = `${features.length} places within ${km} km`;
      } catch (err) {
        if (preferLive) {
          setStatus("Live OSM unavailable, using local data", "warning");
          return fetchAmenitiesRadius(latlng, subjectLabel, remember, true);
        }
        setStatus(err.message || "Unable to fetch data", "danger");
      } finally {
        setLoading(false);
      }

      rememberOrigin("radius", latlng, remember);
    }

    function fetchAreas(populateOnly = false) {
      return fetch("/api/areas/")
        .then(handleResponse)
        .then(fc => {
          areasLayer.clearLayers();
          if (fc.features?.length) {
            areasLayer.addData(fc);
            areaSelect.innerHTML = '<option value="">Select an area to explore</option>';
            fc.features.forEach(f => {
              const opt = document.createElement("option");
              const id = f.id || f.properties.id || f.properties.pk;
              opt.value = id;
              opt.textContent = f.properties.name || `Area ${id}`;
              areaSelect.appendChild(opt);
            });
            if (!populateOnly) {
              map.fitBounds(areasLayer.getBounds(), { padding: [50, 50] });
              setStatus(`Loaded ${fc.features.length} areas`, "success");
            }
          }
          return fc;
        })
        .catch(err => setStatus(err.message, "danger"));
    }

    function fetchRoutesIntersecting(areaId) {
      const url = new URL("/api/routes/intersecting", window.location.origin);
      url.searchParams.set("area_id", areaId);
      setStatus("Finding intersecting routes‚Ä¶");
      fetch(url)
        .then(handleResponse)
        .then(fc => {
          routesLayer.clearLayers();
          if (fc.features?.length) {
            routesLayer.addData(fc);
            setStatus(`Found ${fc.features.length} routes`, "success");
          } else {
            setStatus("No routes intersect this area", "info");
          }
        })
        .catch(err => setStatus(err.message, "danger"));
    }

    function setMode(newMode) {
      state.mode = newMode;
      radiusSection.classList.toggle("d-none", newMode !== "radius");
      map.getContainer().style.cursor = newMode === "radius" ? "crosshair" : "";
      const hint = newMode === "nearest"
        ? "Click the map to find nearby places"
        : "Click the map to search within the radius";
      setStatus(hint, "info");
      if (newMode !== "radius") clearRadiusOverlay();
      replayActiveSearch();
    }

    // Event listeners
    map.on("click", e => {
      if (state.mode === "radius") {
        fetchAmenitiesRadius(e.latlng);
      } else {
        fetchAmenitiesNearest(e.latlng);
      }
    });

    locateButton.addEventListener("click", () => {
      setStatus("Finding your location‚Ä¶");
      attemptLocateUser({ manual: true });
    });

    document.getElementById("resetView").addEventListener("click", () => {
      state.areaId = null;
      state.lastOrigin.radius = null;
      if (state.userLocation) {
        state.lastOrigin.nearest = state.userLocation;
      } else {
        state.lastOrigin.nearest = null;
      }
      clearRadiusOverlay();
      amenityLayerIndex.clear();
      amenitiesLayer.clearLayers();
      routesLayer.clearLayers();
      areaSelect.value = "";
      map.setView([53.3498, -6.2603], 13);
      resultsList.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 16px; opacity: 0.5;">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
            <circle cx="12" cy="10" r="3"/>
          </svg>
          <p style="margin: 0;">Click anywhere on the map<br>to discover nearby places</p>
        </div>
      `;
      resultSummary.textContent = "Click the map to explore";
      setStatus("View reset", "info");
    });

    document.getElementById("btnClearRoutes").addEventListener("click", () => {
      routesLayer.clearLayers();
      setStatus("Routes cleared", "info");
    });

    modeButtons.forEach(btn => {
      btn.addEventListener("click", e => {
        modeButtons.forEach(b => b.classList.remove("active"));
        e.currentTarget.classList.add("active");
        setMode(e.currentTarget.dataset.mode);
      });
    });

    categoryChips.forEach(chip => {
      chip.addEventListener("click", () => {
        const cat = chip.dataset.category;
        if (cat === "all") {
          state.selectedCategories.clear();
        } else {
          if (state.selectedCategories.has(cat)) {
            state.selectedCategories.delete(cat);
          } else {
            state.selectedCategories.add(cat);
          }
        }
        updateCategoryChipsUI();
        replayActiveSearch();
      });
    });

    searchInput.addEventListener("input", () => {
      if (searchDebounce) clearTimeout(searchDebounce);
      searchDebounce = setTimeout(() => {
        state.searchTerm = searchInput.value.trim().toLowerCase();
        replayActiveSearch();
      }, 200);
    });

    if (liveToggle) {
      liveToggle.addEventListener("change", (e) => {
        state.useLiveOSM = e.target.checked;
        const label = state.useLiveOSM ? "Live OSM" : "Local DB";
        setStatus(`Data source: ${label}`, "info");
        replayActiveSearch();
      });
    }

    areaSelect.addEventListener("change", e => {
      const areaId = e.target.value;
      state.areaId = areaId || null;
      if (!areaId) {
        routesLayer.clearLayers();
        setStatus("Area filter cleared", "info");
        replayActiveSearch();
        return;
      }
      const layer = areasLayer.getLayers().find(l => {
        const f = l.feature || {};
        const id = f.id || f.properties?.id || f.properties?.pk;
        return String(id) === areaId;
      });
      if (layer) {
        map.fitBounds(layer.getBounds(), { padding: [50, 50] });
        fetchRoutesIntersecting(areaId);
      }
    });

    radiusInput.addEventListener("input", () => {
      updateRangeLabels();
      if (state.mode === "radius") replayActiveSearch();
    });

    // Initialize
    if (isAuthenticated) {
      loadFavorites();
    }
    updateCategoryChipsUI();
    fetchAreas(true);
    updateRangeLabels();
    setMode(state.mode);
    attemptLocateUser();
  }

  initMap();
});
</script>
{% endblock %}
