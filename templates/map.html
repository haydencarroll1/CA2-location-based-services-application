{% extends "base.html" %}
{% block content %}
<!-- 
  DUBLIN AMENITIES EXPLORER - Fixed Version
  - Area selection now searches amenities
  - Removed duplicate popup code
  - Cleaner UI state management
-->

<div class="app-container">
  <!-- Full-Screen Map -->
  <div id="map"></div>
  
  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay">
    <div class="loading-spinner"></div>
  </div>

  <!-- Floating Search Bar -->
  <div class="search-bar-container">
    <div class="search-bar">
      <svg class="search-bar__icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="11" cy="11" r="8"/>
        <path d="m21 21-4.3-4.3"/>
      </svg>
      <input 
        id="searchInput" 
        type="search" 
        class="search-bar__input" 
        placeholder="Search caf√©s, gyms, parks, ATMs..."
        autocomplete="off"
      >
      <button id="locateMe" class="search-bar__btn" title="Use my location">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"/>
          <path d="M12 2v4m0 12v4M2 12h4m12 0h4"/>
        </svg>
      </button>
    </div>
  </div>

  <!-- Brand Badge -->
  <div class="brand-badge">
    <div class="brand-badge__logo">DAE</div>
    <div>
      <div class="brand-badge__text">Dublin Explorer</div>
      <div class="brand-badge__tech">Leaflet ¬∑ PostGIS</div>
    </div>
  </div>

  <!-- Floating Side Panel -->
  <aside class="side-panel">
    <div class="glass-panel control-panel">
      <div class="panel-header">
        <div>
          <h2 class="panel-title">Explore Dublin</h2>
          <p class="panel-subtitle">Find nearby places</p>
        </div>
        <!-- Live badge now shows actual state -->
        <div id="liveIndicator" class="live-badge" style="display: none;">
          <span class="live-badge__dot"></span>
          Live
        </div>
      </div>

      <!-- Mode Toggle -->
      <div class="mode-toggle" role="group" aria-label="Search mode">
        <button type="button" class="mode-toggle__btn active" data-mode="nearest">
          <span>üìç</span> Nearby
        </button>
        <button type="button" class="mode-toggle__btn" data-mode="radius">
          <span>‚≠ï</span> Radius
        </button>
      </div>

      <!-- Categories -->
      <div class="category-section">
        <div class="section-label">Categories</div>
        <div id="categoryChips" class="category-pills">
          <button class="category-pill active" data-category="all">
            <span class="category-pill__icon">‚ú®</span> All
          </button>
          <button class="category-pill" data-category="cafe">
            <span class="category-pill__icon">‚òï</span> Caf√©s
          </button>
          <button class="category-pill" data-category="shop">
            <span class="category-pill__icon">üõí</span> Shops
          </button>
          <button class="category-pill" data-category="gym">
            <span class="category-pill__icon">üí™</span> Gyms
          </button>
          <button class="category-pill" data-category="atm">
            <span class="category-pill__icon">üèß</span> ATMs
          </button>
          <button class="category-pill" data-category="park">
            <span class="category-pill__icon">üå≥</span> Parks
          </button>
        </div>
      </div>

      <!-- Live OSM Toggle -->
      <div class="category-section">
        <div class="section-label">Data Source</div>
        <label class="switch-row">
          <div>
            <div class="fw-semibold">Live OSM</div>
            <div class="muted small">Fetch from OpenStreetMap</div>
          </div>
          <div class="form-check form-switch mb-0">
            <input class="form-check-input" type="checkbox" role="switch" id="liveToggle">
          </div>
        </label>
      </div>

      <!-- Radius Controls (Hidden by default) -->
      <div id="radiusControls" class="radius-control d-none">
        <div class="radius-control__header">
          <span class="section-label">Search Radius</span>
          <span id="radiusValue" class="radius-control__value">1.0 km</span>
        </div>
        <input 
          id="radiusKm" 
          type="range" 
          class="radius-slider"
          min="0.2" 
          max="5" 
          step="0.1" 
          value="1.0"
        >
      </div>

      <!-- Area Select -->
      <div class="area-select-wrapper">
        <div class="section-label">Area Filter</div>
        <select id="areaSelect" class="area-select">
          <option value="">All areas</option>
        </select>
      </div>

      <!-- Action Buttons -->
      <div class="action-buttons">
        <div class="btn-row">
          <button id="resetView" class="btn btn-secondary">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
              <path d="M3 3v5h5"/>
            </svg>
            Reset
          </button>
          <button id="btnClearAll" class="btn btn-secondary">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18 6 6 18M6 6l12 12"/>
            </svg>
            Clear All
          </button>
        </div>
      </div>
    </div>

    <!-- Results Panel -->
    <div class="glass-panel results-panel">
      <div class="results-panel__header">
        <h3 class="results-panel__title">Results</h3>
        <div id="resultSummary" class="results-panel__count">Click the map to explore</div>
      </div>
      <div id="resultsList" class="results-panel__list">
        <div class="empty-state" style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 16px; opacity: 0.5;">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
            <circle cx="12" cy="10" r="3"/>
          </svg>
          <p style="margin: 0;">Click anywhere on the map<br>to discover nearby places</p>
        </div>
      </div>
    </div>
  </aside>

  <!-- Map Controls -->
  <div class="map-controls">
    <button class="map-control-btn" id="zoomIn" title="Zoom in">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M12 5v14M5 12h14"/>
      </svg>
    </button>
    <button class="map-control-btn" id="zoomOut" title="Zoom out">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M5 12h14"/>
      </svg>
    </button>
    <button class="map-control-btn" id="toggleSatellite" title="Toggle satellite view">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="10"/>
        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/>
        <path d="M2 12h20"/>
      </svg>
    </button>
  </div>

  <!-- Map Legend -->
  <div class="map-legend">
    <div class="legend-item">
      <span class="legend-dot legend-dot--amenity"></span>
      Amenities
    </div>
    <div class="legend-item">
      <span class="legend-dot legend-dot--route"></span>
      Routes
    </div>
    <div class="legend-item">
      <span class="legend-dot legend-dot--area"></span>
      Areas
    </div>
    <div class="legend-item legend-item--clickable" onclick="window.HeatmapModule && HeatmapModule.toggle()">
      <span class="legend-dot legend-dot--heat"></span>
      Heatmap
    </div>
  </div>

  <!-- Status Toast -->
  <div id="statusToast" class="status-toast d-none">
    <svg class="status-toast__icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="10"/>
      <path d="M12 16v-4M12 8h.01"/>
    </svg>
    <span id="statusText" class="status-toast__text"></span>
  </div>
</div>

<script>
window.addEventListener("DOMContentLoaded", function() {
  const isAuthenticated = "{{ request.user.is_authenticated|yesno:'true,false' }}" === "true";
  window.isAuthenticated = isAuthenticated;

  function initMap() {
    if (typeof L === "undefined") {
      setTimeout(initMap, 100);
      return;
    }

    // Initialize map
    const map = L.map("map", {
      scrollWheelZoom: true,
      zoomControl: false,
    }).setView([53.3498, -6.2603], 13);

    // Tile layers
    const darkTiles = L.tileLayer("https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png", {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="https://carto.com/attributions">CARTO</a>',
      maxZoom: 19,
    }).addTo(map);

    const satelliteTiles = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
      attribution: '&copy; Esri',
      maxZoom: 19,
    });

    let isSatellite = false;

    // Initialize feature modules
    if (typeof RoutingModule !== "undefined") RoutingModule.init(map);
    if (typeof HeatmapModule !== "undefined") HeatmapModule.init(map);
    if (typeof WeatherModule !== "undefined") WeatherModule.init(map);

    // Custom zoom controls
    document.getElementById("zoomIn").addEventListener("click", () => map.zoomIn());
    document.getElementById("zoomOut").addEventListener("click", () => map.zoomOut());
    document.getElementById("toggleSatellite").addEventListener("click", () => {
      if (isSatellite) {
        map.removeLayer(satelliteTiles);
        map.addLayer(darkTiles);
      } else {
        map.removeLayer(darkTiles);
        map.addLayer(satelliteTiles);
      }
      isSatellite = !isSatellite;
      document.getElementById("toggleSatellite").classList.toggle("active", isSatellite);
    });

    // DOM references
    const searchInput = document.getElementById("searchInput");
    const radiusSection = document.getElementById("radiusControls");
    const radiusInput = document.getElementById("radiusKm");
    const radiusValueLabel = document.getElementById("radiusValue");
    const areaSelect = document.getElementById("areaSelect");
    const resultsList = document.getElementById("resultsList");
    const resultSummary = document.getElementById("resultSummary");
    const statusToast = document.getElementById("statusToast");
    const statusText = document.getElementById("statusText");
    const loadingOverlay = document.getElementById("loadingOverlay");
    const locateButton = document.getElementById("locateMe");
    const modeButtons = document.querySelectorAll(".mode-toggle__btn");
    const categoryChips = document.querySelectorAll(".category-pill");
    const liveToggle = document.getElementById("liveToggle");
    const liveIndicator = document.getElementById("liveIndicator");

    // State
    const state = {
      mode: "nearest",
      selectedCategories: new Set(),
      searchTerm: "",
      userLocation: null,
      lastOrigin: { nearest: null, radius: null },
      areaId: null,
      useLiveOSM: false,
    };

    let searchDebounce = null;
    let statusTimeout = null;

    // Icon handling
    const amenityIconCache = new Map();
    const amenityIconSlugs = new Set(["cafe", "shop", "gym", "atm", "park", "default"]);
    
    function categoryToSlug(category) {
      if (!category) return "default";
      return amenityIconSlugs.has(category) ? category : "default";
    }

    function createAmenityIcon(category) {
      const slug = categoryToSlug(category);
      if (!amenityIconCache.has(slug)) {
        amenityIconCache.set(slug, L.icon({
          iconUrl: `/static/img/pin-${slug}.svg`,
          iconSize: [36, 44],
          iconAnchor: [18, 42],
          popupAnchor: [0, -38],
        }));
      }
      return amenityIconCache.get(slug);
    }

    const userIcon = L.divIcon({
      className: "user-marker",
      html: '<div class="user-marker__ring"></div><div class="user-marker__dot"></div>',
      iconSize: [24, 24],
      iconAnchor: [12, 12],
    });

    const radiusIcon = L.divIcon({
      className: "radius-pin-icon",
      html: "<span></span>",
      iconSize: [18, 18],
      iconAnchor: [9, 9],
    });

    // Markers and layers
    let userMarker = null;
    let userAccuracyCircle = null;
    let radiusMarker = null;
    let radiusCircle = null;
    const amenityLayerIndex = new Map();
    const favoriteIds = new Set();
    const favoriteLookup = new Map();

    // Single popup builder function (removes duplicate)
    function buildPopupContent(feature) {
      const props = feature.properties || {};
      const name = props.name || "Unnamed";
      const category = props.category || "place";
      const address = props.addr_street || "";
      const coords = feature.geometry?.coordinates || [];
      const lat = coords[1];
      const lng = coords[0];
      const canRoute = Number.isFinite(lat) && Number.isFinite(lng);
      const amenityId = feature.id || props.pk || props.id;

      let html = `
        <div style="min-width: 180px;">
          <strong style="font-size: 14px; display: block; margin-bottom: 4px;">${name}</strong>
          <span style="display: inline-block; padding: 2px 8px; background: rgba(139, 92, 246, 0.2); border-radius: 4px; font-size: 11px; text-transform: uppercase; margin-bottom: 6px;">${category}</span>
          ${address ? `<p style="margin: 4px 0; font-size: 12px; color: #94a3b8;">${address}</p>` : ''}
      `;
      
      if (canRoute) {
        html += `<button class="popup-route-btn" onclick="window.getDirectionsTo(${lat}, ${lng})">üß≠ Get Directions</button>`;
      }
      
      if (isAuthenticated && amenityId) {
        const isFav = favoriteIds.has(String(amenityId));
        html += `<button class="popup-route-btn" onclick="window.toggleFavorite(${amenityId})">${isFav ? "‚òÖ Saved" : "‚òÜ Save"}</button>`;
      }
      
      html += '</div>';
      return html;
    }

    // Layer groups
    const amenitiesLayer = L.geoJSON(null, {
      pointToLayer: (feature, latlng) => L.marker(latlng, {
        icon: createAmenityIcon(feature?.properties?.category),
        riseOnHover: true,
      }),
      onEachFeature: (feature, layer) => {
        layer.bindPopup(buildPopupContent(feature));
        const id = feature.id || feature.properties?.pk || feature.properties?.id;
        if (id) amenityLayerIndex.set(id, layer);
      }
    }).addTo(map);

    const routesLayer = L.geoJSON(null, {
      style: {
        color: "#10b981",
        weight: 4,
        opacity: 0.8,
        lineCap: "round",
        lineJoin: "round"
      },
      onEachFeature: (feature, layer) => {
        layer.bindPopup(`<strong>${feature.properties?.name || "Route"}</strong>`);
      }
    }).addTo(map);

    const areasLayer = L.geoJSON(null, {
      style: {
        color: "#8b5cf6",
        weight: 2,
        opacity: 0.6,
        fillColor: "#8b5cf6",
        fillOpacity: 0.1,
        dashArray: "8, 4"
      }
    }).addTo(map);

    // UI Functions
    function setLoading(isLoading) {
      loadingOverlay.classList.toggle("active", isLoading);
    }

    function setStatus(message, type = "info") {
      statusText.textContent = message;
      statusToast.classList.remove("d-none", "status-toast--success", "status-toast--error");
      if (type === "success") statusToast.classList.add("status-toast--success");
      if (type === "danger") statusToast.classList.add("status-toast--error");
      
      if (statusTimeout) clearTimeout(statusTimeout);
      statusTimeout = setTimeout(() => statusToast.classList.add("d-none"), 4000);
    }

    function getCSRFToken() {
      const cookies = document.cookie ? document.cookie.split(";") : [];
      for (const cookie of cookies) {
        const c = cookie.trim();
        if (c.startsWith("csrftoken=")) {
          return decodeURIComponent(c.substring(10));
        }
      }
      return null;
    }

    function handleResponse(res) {
      if (!res.ok) throw new Error(`Server error: ${res.status}`);
      return res.json();
    }

    // Favorites
    function refreshFavoriteButtons() {
      document.querySelectorAll(".favorite-btn").forEach(btn => {
        const id = btn.dataset.id;
        const isFav = favoriteIds.has(id);
        btn.textContent = isFav ? "‚òÖ Saved" : "‚òÜ Save";
        btn.classList.toggle("favorite-btn--active", isFav);
      });
    }

    function loadFavorites() {
      if (!isAuthenticated) return;
      fetch("/api/favorites/", { credentials: "same-origin" })
        .then(handleResponse)
        .then(data => {
          favoriteIds.clear();
          favoriteLookup.clear();
          (data.results || data).forEach(item => {
            const amenityId = String(item.amenity_pk || item.amenity?.id);
            if (amenityId) {
              favoriteIds.add(amenityId);
              favoriteLookup.set(amenityId, item.id);
            }
          });
          refreshFavoriteButtons();
        })
        .catch(() => {});
    }

    window.toggleFavorite = function(amenityId) {
      if (!isAuthenticated) {
        setStatus("Login to save favorites", "warning");
        return;
      }
      const id = String(amenityId);
      const isFav = favoriteIds.has(id);
      const csrfToken = getCSRFToken();
      if (!csrfToken) {
        setStatus("Missing CSRF token", "danger");
        return;
      }

      if (isFav) {
        const favId = favoriteLookup.get(id);
        if (!favId) {
          favoriteIds.delete(id);
          refreshFavoriteButtons();
          return;
        }
        fetch(`/api/favorites/${favId}/`, {
          method: "DELETE",
          headers: { "X-CSRFToken": csrfToken },
          credentials: "same-origin",
        }).then(resp => {
          if (!resp.ok && resp.status !== 204) throw new Error();
          favoriteIds.delete(id);
          favoriteLookup.delete(id);
          refreshFavoriteButtons();
          setStatus("Removed from favorites", "info");
        }).catch(() => setStatus("Could not remove favorite", "danger"));
      } else {
        fetch("/api/favorites/", {
          method: "POST",
          headers: { "Content-Type": "application/json", "X-CSRFToken": csrfToken },
          credentials: "same-origin",
          body: JSON.stringify({ amenity_id: amenityId })
        }).then(handleResponse).then(created => {
          favoriteIds.add(id);
          if (created?.id) favoriteLookup.set(id, created.id);
          refreshFavoriteButtons();
          setStatus("Saved to favorites", "success");
        }).catch(() => setStatus("Could not save favorite", "danger"));
      }
    };

    window.getDirectionsTo = function(lat, lng) {
      if (typeof RoutingModule === "undefined") {
        setStatus("Routing unavailable", "warning");
        return;
      }
      if (!state.userLocation) {
        setStatus("Enable location to get directions", "warning");
        return;
      }
      RoutingModule.showRoute(state.userLocation, L.latLng(lat, lng), window.currentRoutingMode || "walking")
        .then(result => setStatus(`Route: ${result.durationText} (${result.distanceText})`, "success"))
        .catch(() => setStatus("Could not calculate route", "danger"));
    };

    function updateRangeLabels() {
      radiusValueLabel.textContent = `${parseFloat(radiusInput.value).toFixed(1)} km`;
    }

    function updateCategoryChipsUI() {
      categoryChips.forEach(chip => {
        const cat = chip.dataset.category;
        const isActive = cat === "all" ? state.selectedCategories.size === 0 : state.selectedCategories.has(cat);
        chip.classList.toggle("active", isActive);
      });
    }

    function applyFilters(features) {
      return features.filter(f => {
        const props = f.properties || {};
        if (state.selectedCategories.size > 0 && !state.selectedCategories.has(props.category)) return false;
        if (state.searchTerm) {
          const searchable = [props.name, props.operator, props.cuisine, props.addr_street]
            .filter(Boolean).join(" ").toLowerCase();
          if (!searchable.includes(state.searchTerm)) return false;
        }
        return true;
      });
    }

    function syncAmenityLayer(features) {
      amenitiesLayer.clearLayers();
      amenityLayerIndex.clear();
      if (!features.length) return;
      
      const fc = { type: "FeatureCollection", features };
      amenitiesLayer.addData(fc);
      
      // Re-index after adding
      amenitiesLayer.eachLayer(layer => {
        const f = layer.feature;
        const id = f?.id || f?.properties?.pk || f?.properties?.id;
        if (id) amenityLayerIndex.set(id, layer);
      });
    }

    function renderResults(features) {
      if (!features.length) {
        resultsList.innerHTML = `
          <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
            <p style="margin: 0;">No results found</p>
          </div>`;
        return;
      }
      
      resultsList.innerHTML = features.map((f, i) => {
        const props = f.properties || {};
        const id = f.id || props.pk || props.id;
        const distance = props.distance_m ? `${(props.distance_m / 1000).toFixed(2)} km` : "";
        return `
          <div class="result-card" data-id="${id}">
            <span class="result-card__index">${i + 1}</span>
            <div class="result-card__content">
              <div class="result-card__title">${props.name || "Unnamed"}</div>
              <div class="result-card__meta">
                <span class="result-card__badge">${props.category || "place"}</span>
                ${distance ? `<span class="result-card__distance">${distance}</span>` : ""}
              </div>
            </div>
            ${isAuthenticated && id ? `<button class="favorite-btn" data-id="${id}">${favoriteIds.has(String(id)) ? "‚òÖ Saved" : "‚òÜ Save"}</button>` : ""}
          </div>`;
      }).join("");

      // Click handlers
      resultsList.querySelectorAll(".result-card").forEach(card => {
        card.addEventListener("click", e => {
          if (e.target.classList.contains("favorite-btn")) return;
          const layer = amenityLayerIndex.get(parseInt(card.dataset.id)) || amenityLayerIndex.get(card.dataset.id);
          if (layer) {
            map.flyTo(layer.getLatLng(), 16, { duration: 0.5 });
            layer.openPopup();
          }
        });
      });
      
      resultsList.querySelectorAll(".favorite-btn").forEach(btn => {
        btn.addEventListener("click", e => {
          e.stopPropagation();
          window.toggleFavorite(btn.dataset.id);
        });
      });
    }

    // Location tracking
    function setUserLocation(latlng, accuracy) {
      state.userLocation = latlng;
      if (!userMarker) {
        userMarker = L.marker(latlng, { icon: userIcon }).addTo(map);
        userAccuracyCircle = L.circle(latlng, {
          radius: accuracy,
          color: "#06b6d4",
          fillColor: "#06b6d4",
          fillOpacity: 0.1,
          weight: 1
        }).addTo(map);
      } else {
        userMarker.setLatLng(latlng);
        userAccuracyCircle.setLatLng(latlng).setRadius(accuracy);
      }
      if (typeof WeatherModule !== "undefined") WeatherModule.updateForLocation(latlng);
    }

    function attemptLocateUser(options = {}) {
      if (!navigator.geolocation) {
        setStatus("Geolocation not supported", "danger");
        return;
      }
      setLoading(true);
      navigator.geolocation.getCurrentPosition(
        pos => {
          const latlng = L.latLng(pos.coords.latitude, pos.coords.longitude);
          setUserLocation(latlng, pos.coords.accuracy);
          state.lastOrigin.nearest = latlng;
          if (options.manual) {
            map.flyTo(latlng, 15, { duration: 1 });
            fetchAmenities(latlng, "your location");
          }
          setLoading(false);
        },
        () => {
          setStatus("Could not get location", "danger");
          setLoading(false);
        },
        { enableHighAccuracy: true, timeout: 10000 }
      );
    }

    // Radius overlay
    function updateRadiusOverlay(latlng, km) {
      const radiusM = km * 1000;
      if (!radiusMarker) {
        radiusMarker = L.marker(latlng, { icon: radiusIcon }).addTo(map);
        radiusCircle = L.circle(latlng, {
          radius: radiusM,
          className: "radius-circle",
          color: "#06b6d4",
          fillColor: "#06b6d4",
          fillOpacity: 0.08,
          weight: 2,
          dashArray: "8 4"
        }).addTo(map);
      } else {
        radiusMarker.setLatLng(latlng);
        radiusCircle.setLatLng(latlng).setRadius(radiusM);
      }
    }

    function clearRadiusOverlay() {
      if (radiusMarker) { map.removeLayer(radiusMarker); radiusMarker = null; }
      if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
    }

    function getSelectedCategories() {
      return state.selectedCategories.size === 0 ? [] : Array.from(state.selectedCategories);
    }

    // FIX: Unified fetch function that respects area selection
    async function fetchAmenities(latlng, label, remember = true, forceLocal = false) {
      const isRadius = state.mode === "radius";
      const km = isRadius ? parseFloat(radiusInput.value) : 1;
      
      if (isRadius) {
        updateRadiusOverlay(latlng, km);
      } else {
        clearRadiusOverlay();
      }
      
      setLoading(true);
      const displayLabel = label || `${latlng.lat.toFixed(4)}, ${latlng.lng.toFixed(4)}`;
      setStatus(`Finding places near ${displayLabel}‚Ä¶`);

      const preferLive = !forceLocal && state.useLiveOSM && typeof LiveOSM !== "undefined";

      try {
        let features = [];
        let routesFC = { features: [] };

        if (preferLive) {
          features = await LiveOSM.fetchAmenities(latlng.lat, latlng.lng, km, getSelectedCategories(), map.getBounds());
        } else {
          // Build amenities URL
          const endpoint = isRadius ? "/api/amenities/radius" : "/api/amenities/nearest";
          const amenitiesUrl = new URL(endpoint, window.location.origin);
          amenitiesUrl.searchParams.set("lat", latlng.lat);
          amenitiesUrl.searchParams.set("lng", latlng.lng);
          if (isRadius) {
            amenitiesUrl.searchParams.set("km", km);
          } else {
            amenitiesUrl.searchParams.set("limit", 20);
          }
          // FIX: Add area filter to API call if selected
          if (state.areaId) {
            amenitiesUrl.searchParams.set("area_id", state.areaId);
          }

          // Build routes URL (for radius mode)
          if (isRadius) {
            const routesUrl = new URL("/api/routes/radius", window.location.origin);
            routesUrl.searchParams.set("lat", latlng.lat);
            routesUrl.searchParams.set("lng", latlng.lng);
            routesUrl.searchParams.set("km", km);

            const [amenitiesFC, routesData] = await Promise.all([
              fetch(amenitiesUrl).then(handleResponse),
              fetch(routesUrl).then(handleResponse)
            ]);
            features = amenitiesFC.features || [];
            routesFC = routesData;
          } else {
            const amenitiesFC = await fetch(amenitiesUrl).then(handleResponse);
            features = amenitiesFC.features || [];
          }
        }

        // Apply client-side filters
        features = applyFilters(features);
        
        // Update map layers
        syncAmenityLayer(features);
        if (typeof HeatmapModule !== "undefined") HeatmapModule.setData(features);
        
        routesLayer.clearLayers();
        if (routesFC.features?.length) routesLayer.addData(routesFC);
        
        // Zoom to results
        if (features.length) {
          map.flyTo(latlng, Math.max(map.getZoom(), isRadius ? 14 : 15), { duration: 0.5 });
        }
        
        renderResults(features);
        
        const routeInfo = routesFC.features?.length ? ` and ${routesFC.features.length} routes` : "";
        setStatus(`Found ${features.length} amenities${routeInfo}`, "success");
        resultSummary.textContent = isRadius 
          ? `${features.length} places within ${km} km` 
          : `${features.length} places near ${displayLabel}`;

      } catch (err) {
        if (preferLive) {
          setStatus("Live OSM unavailable, using local data", "warning");
          return fetchAmenities(latlng, label, remember, true);
        }
        setStatus(err.message || "Unable to fetch data", "danger");
      } finally {
        setLoading(false);
      }

      if (remember) state.lastOrigin[state.mode] = latlng;
    }

    // FIX: Area-specific amenity fetch
    async function fetchAmenitiesInArea(areaId) {
      setLoading(true);
      setStatus("Finding amenities in area‚Ä¶");

      try {
        const url = new URL("/api/amenities/in-area", window.location.origin);
        url.searchParams.set("area_id", areaId);
        
        const fc = await fetch(url).then(handleResponse);
        let features = fc.features || [];
        
        features = applyFilters(features);
        syncAmenityLayer(features);
        if (typeof HeatmapModule !== "undefined") HeatmapModule.setData(features);
        
        renderResults(features);
        setStatus(`Found ${features.length} amenities in area`, "success");
        resultSummary.textContent = `${features.length} places in selected area`;
        
      } catch (err) {
        // Fallback: if no area endpoint exists, just zoom to area
        setStatus("Area filter applied - click map to search", "info");
      } finally {
        setLoading(false);
      }
    }

    function replayActiveSearch() {
      const origin = state.lastOrigin[state.mode];
      if (!origin) return;
      fetchAmenities(origin, null, false);
    }

    function fetchAreas(populateOnly = false) {
      return fetch("/api/areas/")
        .then(handleResponse)
        .then(fc => {
          areasLayer.clearLayers();
          if (fc.features?.length) {
            areasLayer.addData(fc);
            areaSelect.innerHTML = '<option value="">All areas</option>';
            fc.features.forEach(f => {
              const opt = document.createElement("option");
              const id = f.id || f.properties.id || f.properties.pk;
              opt.value = id;
              opt.textContent = f.properties.name || `Area ${id}`;
              areaSelect.appendChild(opt);
            });
            if (!populateOnly) {
              map.fitBounds(areasLayer.getBounds(), { padding: [50, 50] });
              setStatus(`Loaded ${fc.features.length} areas`, "success");
            }
          }
          return fc;
        })
        .catch(err => setStatus(err.message, "danger"));
    }

    function fetchRoutesIntersecting(areaId) {
      const url = new URL("/api/routes/intersecting", window.location.origin);
      url.searchParams.set("area_id", areaId);
      fetch(url)
        .then(handleResponse)
        .then(fc => {
          routesLayer.clearLayers();
          if (fc.features?.length) routesLayer.addData(fc);
        })
        .catch(() => {});
    }

    function setMode(newMode) {
      state.mode = newMode;
      radiusSection.classList.toggle("d-none", newMode !== "radius");
      map.getContainer().style.cursor = newMode === "radius" ? "crosshair" : "";
      setStatus(newMode === "nearest" ? "Click the map to find nearby places" : "Click the map to search within radius", "info");
      if (newMode !== "radius") clearRadiusOverlay();
      replayActiveSearch();
    }

    // Event listeners
    map.on("click", e => fetchAmenities(e.latlng));

    locateButton.addEventListener("click", () => {
      setStatus("Finding your location‚Ä¶");
      attemptLocateUser({ manual: true });
    });

    document.getElementById("resetView").addEventListener("click", () => {
      state.areaId = null;
      state.lastOrigin = { nearest: null, radius: null };
      clearRadiusOverlay();
      amenityLayerIndex.clear();
      amenitiesLayer.clearLayers();
      routesLayer.clearLayers();
      areaSelect.value = "";
      map.setView([53.3498, -6.2603], 13);
      resultsList.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto 16px; opacity: 0.5;">
            <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/>
            <circle cx="12" cy="10" r="3"/>
          </svg>
          <p style="margin: 0;">Click anywhere on the map<br>to discover nearby places</p>
        </div>`;
      resultSummary.textContent = "Click the map to explore";
      setStatus("View reset", "info");
    });

    // FIX: Clear All button now clears everything
    document.getElementById("btnClearAll").addEventListener("click", () => {
      amenitiesLayer.clearLayers();
      amenityLayerIndex.clear();
      routesLayer.clearLayers();
      clearRadiusOverlay();
      resultsList.innerHTML = `
        <div style="text-align: center; padding: 40px 20px; color: var(--text-muted);">
          <p style="margin: 0;">Cleared - click map to search</p>
        </div>`;
      resultSummary.textContent = "Click the map to explore";
      setStatus("Cleared all results", "info");
    });

    modeButtons.forEach(btn => {
      btn.addEventListener("click", e => {
        modeButtons.forEach(b => b.classList.remove("active"));
        e.currentTarget.classList.add("active");
        setMode(e.currentTarget.dataset.mode);
      });
    });

    categoryChips.forEach(chip => {
      chip.addEventListener("click", () => {
        const cat = chip.dataset.category;
        if (cat === "all") {
          state.selectedCategories.clear();
        } else {
          state.selectedCategories.has(cat) ? state.selectedCategories.delete(cat) : state.selectedCategories.add(cat);
        }
        updateCategoryChipsUI();
        replayActiveSearch();
      });
    });

    searchInput.addEventListener("input", () => {
      if (searchDebounce) clearTimeout(searchDebounce);
      searchDebounce = setTimeout(() => {
        state.searchTerm = searchInput.value.trim().toLowerCase();
        replayActiveSearch();
      }, 200);
    });

    if (liveToggle) {
      liveToggle.addEventListener("change", e => {
        state.useLiveOSM = e.target.checked;
        liveIndicator.style.display = state.useLiveOSM ? "flex" : "none";
        setStatus(`Data source: ${state.useLiveOSM ? "Live OSM" : "Local DB"}`, "info");
        replayActiveSearch();
      });
    }

    // FIX: Area selection now searches for amenities
    areaSelect.addEventListener("change", e => {
      const areaId = e.target.value;
      state.areaId = areaId || null;
      
      if (!areaId) {
        // Cleared area filter
        routesLayer.clearLayers();
        setStatus("Area filter cleared", "info");
        replayActiveSearch();
        return;
      }
      
      // Find and zoom to area
      const layer = areasLayer.getLayers().find(l => {
        const f = l.feature || {};
        const id = f.id || f.properties?.id || f.properties?.pk;
        return String(id) === areaId;
      });
      
      if (layer) {
        map.fitBounds(layer.getBounds(), { padding: [50, 50] });
        // Fetch routes and amenities in this area
        fetchRoutesIntersecting(areaId);
        fetchAmenitiesInArea(areaId);
      }
    });

    radiusInput.addEventListener("input", () => {
      updateRangeLabels();
      if (state.mode === "radius") replayActiveSearch();
    });

    // Initialize
    if (isAuthenticated) loadFavorites();
    updateCategoryChipsUI();
    fetchAreas(true);
    updateRangeLabels();
    setMode(state.mode);
    attemptLocateUser();
  }

  initMap();
});
</script>
{% endblock %}
